# A0127047J
###### Tempo\Commands\AddCommand.java
``` java
package Tempo.Commands;

import java.util.*;
import java.text.*;
import Tempo.Logic.Calendar;
import Tempo.Logic.*;

public class AddCommand implements Command {
	private Calendar cal;
	private ArrayList<String> cmdArgs;
	private boolean isRecurring = false;
	private String recurringFrequency;
	private String recurrenceEndDate;
	
	private static final int LENGTH_ADD_EVENT_PARAMS = 3;
	private static final int LENGTH_ADD_TASK_PARAMS = 2;
	
	private static final String ADD_EVENT = "add Event %1$s";
	private static final String ADD_TASK = "add Task %1$s";
	private static final String ADD_FLOATINGTASK = "add Floating Task %1$s";
	private static final String DELIMETER_TIME = ":";
	private static final String DELIMETER_DATE = "/";
	private static final String STR_EMPTY = "";
	
	private static final String INVALID_DATE = "Error: Date(s) entered is invalid!";
	
	private DateFormat dateTimeFormat = new SimpleDateFormat("dd/MM/yyyy HH:mm");
	private DateFormat dateFormat = new SimpleDateFormat("dd/MM/yyyy");
	private DateFormat timeFormat = new SimpleDateFormat("HH:mm");
	
	public AddCommand(Calendar cal, ArrayList<String> params) {
		this.cal = cal;
		this.cmdArgs = params;
	}
	
	public AddCommand(Calendar cal, ArrayList<String> params, boolean isRecurring, 
					  String recurringType, String recurrenceEndDate) {
		this.cal = cal;
		this.cmdArgs = params;
		this.isRecurring = isRecurring;
		this.recurringFrequency = recurringType;
		this.recurrenceEndDate = recurrenceEndDate;
	}
	
	@Override
	public Result execute() {
		saveCommand();
		if (cmdArgs.size() == LENGTH_ADD_EVENT_PARAMS) {
			if(cmdArgs.get(1) == null || cmdArgs.get(2) == null){
				return new Result(INVALID_DATE, true, true, null);
			}
			return executeAddEvent();
		} else if (cmdArgs.size() == LENGTH_ADD_TASK_PARAMS) {
			if(cmdArgs.get(1) == null){
				return new Result(INVALID_DATE, true, true, null);
			}
			return executeAddTask();
		} else {
			return addFloatingTask();		
		}
	}
	
	private Result executeAddEvent() {
		if (isRecurring) {
			return addRecurringEvent();
		} else {
			return addEvent();
		}
	}
	
	private Result executeAddTask() {
		if (isRecurring) {
			return addRecurringTask();
		} else {
			return addTask();
		}
	}
	
	private Result addEvent() {
		String name = cmdArgs.get(0);
		
		if (!hasValidName(name)) {
			return new Result(String.format(ADD_EVENT, STR_EMPTY), false, null);
		}
		
		String start = replaceNullStart(cmdArgs.get(1));
		String end = replaceNullEnd(start, cmdArgs.get(2));
			
		Result result = cal.addEvent(name, start, end);
		
		return result;
	}
	
	private Result addRecurringEvent(){
		String name = cmdArgs.get(0);
		
		if (!hasValidName(name)) {
			return new Result(String.format(ADD_EVENT, STR_EMPTY), false, null);
		}
		
		String start = replaceNullStart(cmdArgs.get(1));
		String end = replaceNullEnd(start, cmdArgs.get(2));
			
		Result result = cal.addRecurringEvent(name, start, end, recurringFrequency, 
											  recurrenceEndDate);
		
		return result;
	}
	
	private Result addTask() {
		String name = cmdArgs.get(0);
		String dueDate = cmdArgs.get(1);
		
		if (!hasValidName(name)) {
			return new Result(String.format(ADD_TASK, STR_EMPTY), false, null);
		}
		
		return cal.addTask(name, dueDate);
	}
	
	private Result addRecurringTask(){
		String name = cmdArgs.get(0);
		String dueDate = cmdArgs.get(1);
		
		if (!hasValidName(name)) {
			return new Result(String.format(ADD_TASK, STR_EMPTY), false, null);
		}
		
		return cal.addRecurringTask(name, dueDate, recurringFrequency, recurrenceEndDate);
	}
	
	private Result addFloatingTask() {
		String name = cmdArgs.get(0);
		
		if (!hasValidName(name)) {
			return new Result(String.format(ADD_FLOATINGTASK, STR_EMPTY), false, null);
		}
		
		return cal.addFloatingTask(name);
	}
	
	private String replaceNullStart(String dateWithTime) {
		if (isEmptyInput(dateWithTime)) { 
			return getCurrDateTimeStr();
		}
		return dateWithTime;
	}
	
	private String replaceNullEnd(String start, String end) {
		if (isEmptyInput(end)) {
			return addTwoHours(start);
		}
		return end;
	}
	
	private String addTwoHours(String start) {
		GregorianCalendar startDate = getCalendarDate(start);
		startDate.add(GregorianCalendar.HOUR, 2);
		return getDateTimeStr(startDate);
	}
	
	private boolean isEmptyInput(String input) {
		return (input == null || input == STR_EMPTY);
	}
	
	private boolean hasValidName(String name) {
		return !isEmptyInput(name);
	}
		
	private CurrentTime getCurrDateTime() {
		return new CurrentTime();
	}
	
	private String getCurrDateTimeStr() {
		CurrentTime curr = getCurrDateTime();
		return curr.getDateAndTime();
	}
	
	private String getDateStr(String dateStr) {
		return dateFormat.format(dateStr);
	}
	
	private String getTimeStr(String dateStr) {
		return timeFormat.format(dateStr);
	}
	
	private String getDateTimeStr(GregorianCalendar date) {
		return dateTimeFormat.format(date);
	}
		
	private GregorianCalendar getCalendarDate(String dateStr) {
		String date = getDateStr(dateStr);
		String[] dateParams = date.trim().split(DELIMETER_DATE);
		
		int year = Integer.valueOf(dateParams[2]);
		int month = Integer.valueOf(dateParams[1]);
		int day = Integer.valueOf(dateParams[0]);
		
		String time = getTimeStr(dateStr);
		String[] timeParams = time.trim().split(DELIMETER_TIME);
		
		int hour = Integer.valueOf(timeParams[0]);
		int min = Integer.valueOf(timeParams[1]);
		
		return new GregorianCalendar(year, month, day, hour, min);
	}
	
	private void saveCommand() {
		if (isRecurring) {
			cal.saveCmd((Command) new AddCommand(cal, cmdArgs, isRecurring, 
												 recurringFrequency, recurrenceEndDate));
		} else {
			cal.saveCmd((Command) new AddCommand(cal, cmdArgs));
		}
	}
}
```
###### Tempo\Commands\RedoCommand.java
``` java
package Tempo.Commands;

import Tempo.Logic.Calendar;

public class RedoCommand implements Command{
	private Calendar cal;
	private static final String CMD_REDO = "redo <%1$s>";
	
	public RedoCommand(Calendar cal){
		this.cal = cal;
	}
	
	public Result execute(){
		Result result = cal.redo();
		String cmd = String.format(CMD_REDO, 
					 result.getCmdPerformed());
		result.setCommand(cmd);
		return result;
	}

}
```
###### Tempo\Commands\RemoveCommand.java
``` java
package Tempo.Commands;

import Tempo.Logic.Calendar;
import Tempo.Logic.*;

public class RemoveCommand implements Command {
	private Calendar cal;
	private IndexStore indexStore;
	private int idx;
	private boolean isSeries;
	
	private static final String MSG_INVALID_ID = 
						"Error: Index provided is invalid!";
	
	public RemoveCommand(Calendar cal, IndexStore indexStore, 
						int idx, boolean isSeries) {
		this.cal = cal;
		this.indexStore = indexStore;
		this.idx = idx;
		this.isSeries = isSeries;
	}
	
	public Result execute(){
		saveCommand();
		
		if (isEvent()) {
			return executeRemoveEvent();
		} else if (isFloatingTask()) {
			return executeRemoveFloating();
		} else if (isTask()) {
			return executeRemoveTask();
		} else {
			return handleInvalidRemove();
		}
	}
	
	private Result executeRemoveEvent() {
		return cal.removeEvent(idx, isSeries);
	}
	
	private Result executeRemoveFloating() {
		return cal.removeFloatingTask(idx, isSeries);
	}
	
	private Result executeRemoveTask() {
		return cal.removeTask(idx, isSeries);
	}
	
	private Result handleInvalidRemove() {
		return new Result(MSG_INVALID_ID, false, null);
	}
	
	private boolean isEvent(){
		return indexStore.isEvent(idx);
	}
	
	private boolean isFloatingTask(){
		return indexStore.isFloatingTask(idx);
	}

	private boolean isTask() {
		return indexStore.isTask(idx);
	}
	
	private void saveCommand() {
		cal.saveCmd((Command) new RemoveCommand(
				cal, indexStore, idx, isSeries));
	}
}
```
###### Tempo\Commands\UndoAdd.java
``` java
package Tempo.Commands;

import Tempo.Logic.Calendar;
import Tempo.Data.*;
import Tempo.Logic.*;

public class UndoAdd implements Command {
	private static Calendar cal = Calendar.getInstance();
	private static IndexStore idxStore = IndexStore.getInstance();
	
	private static final String CMD_UNDO = "undo <add %1$s %2$s>";
	private static final String OBJ_EVENT = "event";
	private static final String OBJ_TASK = "task";
	private static final String OBJ_FLOATING = "floating task";
	
	private int prevModIndex;
	private String nameOfPrevObj;
	private String objType;
	
	private boolean isEvent = false;
	private boolean isTask = false;
	private boolean isSeries = false;
	
	public UndoAdd(int prevModIndex, boolean isEvent, boolean isTask, 
					boolean isSeries) {
		this.prevModIndex = prevModIndex;
		this.isEvent = isEvent;
		this.isTask = isTask;
		this.isSeries = isSeries;
		initialiseNameOfPrevObj();
	}
	
	public Result execute() {
		Result result;
		
		if (isEvent) {
			objType = OBJ_EVENT;
			result = executeRemoveEvent();
		} else if (isTask) {
			objType = OBJ_TASK;
			result = executeRemoveTask();
		} else {
			objType = OBJ_FLOATING;
			result = executeRemoveFloating();
		}
			
		String cmd = String.format(CMD_UNDO, objType, nameOfPrevObj);
		result.setCommand(cmd);
		removeUndoUndoCommand();
				
		return result;
	}
	
	private Result executeRemoveEvent() {
		return cal.removeEvent(prevModIndex, isSeries);
	}
	
	private Result executeRemoveTask() {
		return cal.removeTask(prevModIndex, isSeries);
	}
	
	private Result executeRemoveFloating() {
		return cal.removeFloatingTask(prevModIndex, isSeries);
	}
	
	private void removeUndoUndoCommand() {
		cal.removeLastUndo();
	}
	
	private void initialiseNameOfPrevObj() {
		if (isEvent) {
			Event event = (Event) idxStore.getEventById(prevModIndex);
			setNameOfPrevObj(event.getName());
		} else {
			FloatingTask task = (FloatingTask) idxStore.getTaskById(
														prevModIndex);
			setNameOfPrevObj(task.getName());
		}
	}
	
	private void setNameOfPrevObj(String name) {
		nameOfPrevObj = name;
	}

}
```
###### Tempo\Commands\UndoClear.java
``` java
package Tempo.Commands;

import java.util.*;

import Tempo.Data.*;
import Tempo.Logic.Calendar;

public class UndoClear implements Command {
	private static Calendar cal = Calendar.getInstance();
	
	private static final String CMD_UNDO = "undo <%1$s>";
	
	private ArrayList<CalendarObject> events;
	private ArrayList<CalendarObject> tasks;
	private ArrayList<CalendarObject> floatingTasks;
	
	public UndoClear(ArrayList<CalendarObject> events, 
					 ArrayList<CalendarObject> tasks, 
					 ArrayList<CalendarObject> floatingTasks) {
		this.events = events;
		this.tasks = tasks;
		this.floatingTasks = floatingTasks;
	}
	
	public Result execute() {
		Result result = executeUndoClear();
		
		String cmd = String.format(CMD_UNDO, result.getCmdPerformed());
		result.setCommand(cmd);
		return result;
	}
	
	public Result executeUndoClear() {
		return cal.addBackAll(events, tasks, floatingTasks);
	}

}
```
###### Tempo\Commands\UndoCommand.java
``` java
package Tempo.Commands;

import Tempo.Logic.Calendar;

public class UndoCommand implements Command {
	private Calendar cal;
	
	public UndoCommand(Calendar cal) {
		this.cal  = cal;
	}

	public Result execute() {
		return cal.undo();
	}
	
}
```
###### Tempo\Commands\UndoDone.java
``` java
package Tempo.Commands;

import Tempo.Logic.Calendar;

public class UndoDone implements Command {
	private static Calendar cal = Calendar.getInstance();
	
	private static final String CMD_UNDO = "undo <%1$s %2$s %3$s>";
	private static final String CMD_DONE = "done";
	private static final String CMD_UNDONE = "undone";
	
	private static final String OBJ_TASK = "task";
	private static final String OBJ_FLOATING = "floating task";
	
	private String cmdType;
	private String objType;
	
	private int prevModIndex;
	private boolean isFloating;
	private boolean isDoneCmd = false;
	
	public UndoDone(int prevModIndex, boolean isFloating, 
					boolean isDoneCmd) {
		this.prevModIndex = prevModIndex;
		this.isFloating = isFloating;
		
		if(isFloating) {
			objType = OBJ_FLOATING;
		} else {
			objType = OBJ_TASK;
		}
		
		this.isDoneCmd = isDoneCmd;
	}
	
	public Result execute() {
		Result result;
		
		if (isDoneCmd) {
			cmdType = CMD_DONE;
			result = executeMarkUndone();
		} else {
			cmdType = CMD_UNDONE;
			result = executeMarkDone();
		}
		
		String nameOfItem = getName(result.getCmdPerformed());
		String command = String.format(CMD_UNDO, cmdType, objType, 
									   nameOfItem);
		result.setCommand(command);
		
		removeUndoUndoCommand();
		
		return result;
	}
	
	private Result executeMarkUndone() {
		if(isFloating) {
			return cal.markFloatingTaskAsUndone(prevModIndex);
		} else {
			return cal.markTaskAsUndone(prevModIndex); 
		}
	}
	
	private Result executeMarkDone() {
		if (isFloating) {
			return cal.markFloatingTaskAsDone(prevModIndex);
		} else {
			return cal.markTaskAsDone(prevModIndex);
		}
	}
	
	private void removeUndoUndoCommand() {
		cal.removeLastUndo();
	}
	
	private String getName(String feedbackStr) {
		String[] params = feedbackStr.trim().split(" task ");
		return params[1].trim();
	}
}
```
###### Tempo\Commands\UndoRemove.java
``` java
package Tempo.Commands;

import java.util.*;

import Tempo.Data.*;
import Tempo.Logic.Calendar;

public class UndoRemove implements Command {
	private static Calendar cal = Calendar.getInstance();
	
	private static final String CMD_UNDO = "undo <remove %1$s %2$s>";
	private static final String OBJ_EVENT = "event";
	private static final String OBJ_TASK = "task";
	private static final String OBJ_FLOATING = "floating task";
	
	private String objType;
	private String nameOfPrevObj;
		
	private Event prevModEvent;
	private Task prevModTask;
	private FloatingTask prevModFloating;
	
	private ArrayList<CalendarObject> prevModEvents;
	private ArrayList<CalendarObject> prevModTasks;
	
	private boolean isEvent = false;
	private boolean isTask = false;
	private boolean isFloatingTask = false;
	private boolean isEventsSeries = false;
	
	public UndoRemove(Event event) {
		prevModEvent = event;
		isEvent = true;
		objType = OBJ_EVENT;
	}
	
	public UndoRemove(Task task) {
		prevModTask = task;
		isTask = true;
		objType = OBJ_TASK;
	}
	
	public UndoRemove(FloatingTask floatingTask) {
		prevModFloating = floatingTask;
		isFloatingTask = true;
		objType = OBJ_FLOATING;
	}
	
	public UndoRemove(ArrayList<CalendarObject> series, 
					  boolean isEventsSeries) {
		this.isEventsSeries = isEventsSeries;
		initialiseSeries(series);
	}
	
	public Result execute() {
		Result result;
		
		if (isEvent) {
			result = executeRemoveEvent();
		} else if (isTask) {
			result = executeRemoveTask();
		} else if (isFloatingTask) {
			result = executeRemoveFloating();
		} else if (isEventsSeries) {
			result = executeRemoveEventsSeries();
		} else {
			result = executeRemoveTasksSeries();
		}
		
		initialiseNameOfPrevObj();
		String command = String.format(CMD_UNDO, objType, 
									   nameOfPrevObj);
		result.setCommand(command);
				
		return result;
	}
	
	private Result executeRemoveEvent() {
		return cal.addBackEvent(prevModEvent);
	}
	
	private Result executeRemoveTask() {
		return cal.addBackTask(prevModTask);
	}
	
	private Result executeRemoveFloating() {	
		return cal.addBackFloating(prevModFloating);
	}
	
	private Result executeRemoveEventsSeries() {
		return cal.addBackRecurrEvent(prevModEvents);
	}
	
	private Result executeRemoveTasksSeries() {
		return cal.addBackRecurrTask(prevModTasks);
	}
	
	private void initialiseSeries(ArrayList<CalendarObject> series) {
		if (isEventsSeries) {
			prevModEvents = series;
			objType = OBJ_EVENT;
		} else {
			prevModTasks = series;
			objType = OBJ_TASK;
		}
	}
	
	private void initialiseNameOfPrevObj() {
		if (isEvent) {
			setNameOfPrevObj(prevModEvent.getName());
		} else if (isTask) {
			setNameOfPrevObj(prevModTask.getName());
		} else if (isFloatingTask) {
			setNameOfPrevObj(prevModFloating.getName());
		} else if (isEventsSeries) {
			Event event = (Event) prevModEvents.get(0);
			setNameOfPrevObj(event.getName());
		} else {
			Task task = (Task) prevModTasks.get(0);
			setNameOfPrevObj(task.getName());
		}
	}
	
	private void setNameOfPrevObj(String name) {
		nameOfPrevObj = name;
	}
}
```
###### Tempo\Commands\UndoUpdate.java
``` java
package Tempo.Commands;

import java.util.*;

import Tempo.Data.*;
import Tempo.Logic.Calendar;

public class UndoUpdate implements Command {
	private static Calendar calendar = Calendar.getInstance();
	
	private static final String CMD_UNDO = "undo <update %1$s %2$s>";
	private static final String OBJ_EVENT = "event";
	private static final String OBJ_TASK = "task";
	private static final String OBJ_FLOATING = "floating task";
	
	private String objType;
	private String nameOfPrevObj;
	
	private int prevModIndex;
	private Event prevModEvent;
	private Task prevModTask;
	private FloatingTask prevModFloating;
	
	private ArrayList<CalendarObject> prevModEvents;
	private ArrayList<CalendarObject> prevModTasks;

	private boolean isEvent = false;
	private boolean isTask = false;
	private boolean isFloatingTask = false;
	private boolean isEventsSeries = false;
	
	public UndoUpdate(Event event) {
		prevModEvent = event;
		prevModIndex = event.getIndex();
		isEvent = true;
		objType = OBJ_EVENT;
	}
	
	public UndoUpdate(Task task) {
		prevModTask = task;
		prevModIndex = task.getIndex();
		isTask = true;
		objType = OBJ_TASK;
	}
	
	public UndoUpdate(FloatingTask floatingTask) {
		prevModFloating = floatingTask;
		prevModIndex = floatingTask.getIndex();
		isFloatingTask = true;
		objType = OBJ_FLOATING;
	}
	
	public UndoUpdate(ArrayList<CalendarObject> series, boolean isEventsSeries) {
		this.isEventsSeries = isEventsSeries;
		initialiseSeries(series);
	}
	
	private void initialiseSeries(ArrayList<CalendarObject> series) {
		if (isEventsSeries) {
			prevModEvents = series;
			Event event = (Event) series.get(0);
			prevModIndex = event.getIndex();
			objType = OBJ_EVENT;
		} else {
			prevModTasks = series;
			Task task = (Task) series.get(0);
			prevModIndex = task.getIndex();
			objType = OBJ_TASK;
		}
	}

	public Result execute() {
		initialiseNameOfPrevObj();
		Result result;
		
		if (isEvent) {
			result = undoUpdateEvent();
		} else if (isTask) {
			result = undoUpdateTask();
		} else if (isFloatingTask) {
			result = undoUpdateFloating();
		} else if (isEventsSeries) {
			result = undoUpdateEventsSeries();
		} else {
			result = undoUpdateTasksSeries();
		}
		
		String command = String.format(CMD_UNDO, objType, 
									   nameOfPrevObj);
		result.setCommand(command);
		return result;
	}
	
	private Result undoUpdateEvent() {
		Result result;
		result = calendar.removeEvent(prevModIndex, isEventsSeries);
		removeUndoUndoCommand();
		result = calendar.addBackEvent(prevModEvent);
		return result;
	}
	
	private Result undoUpdateTask() {
		Result result;
		result = calendar.removeTask(prevModIndex, isEventsSeries);
		removeUndoUndoCommand();
		result = calendar.addBackTask(prevModTask);
		return result;
	}
	
	private Result undoUpdateFloating() {
		Result result;
		result = calendar.removeFloatingTask(prevModIndex, isEventsSeries);
		removeUndoUndoCommand();
		result = calendar.addBackFloating(prevModFloating);
		return result;
	}
	
	private Result undoUpdateEventsSeries() {
		Result result;
		result = calendar.removeEvent(prevModIndex, true);
		removeUndoUndoCommand();
		result = calendar.addBackRecurrEvent(prevModEvents);
		return result;
	}
	
	private Result undoUpdateTasksSeries() {
		Result result;
		result = calendar.removeTask(prevModIndex, true);
		removeUndoUndoCommand();
		result = calendar.addBackRecurrTask(prevModTasks);
		return result;
	}
	
	private void removeUndoUndoCommand() {
		calendar.removeLastUndo();
	}
	
	private void initialiseNameOfPrevObj() {
		if (isEvent) {
			setNameOfPrevObj(prevModEvent.getName());
		} else if (isTask) {
			setNameOfPrevObj(prevModTask.getName());
		} else if (isFloatingTask) {
			setNameOfPrevObj(prevModFloating.getName());
		} else if (isEventsSeries) {
			Event event = (Event) prevModEvents.get(0);
			setNameOfPrevObj(event.getName());
		} else {
			Task task = (Task) prevModTasks.get(0);
			setNameOfPrevObj(task.getName());
		}
	}
	
	private void setNameOfPrevObj(String name) {
		nameOfPrevObj = name;
	}

}
```
###### Tempo\Commands\UpdateCommand.java
``` java
package Tempo.Commands;

import java.util.*;

import Tempo.Logic.Calendar;
import Tempo.Logic.IndexStore;

public class UpdateCommand implements Command {
	private static Calendar cal;
	private static IndexStore indexStore;
	
	private static final String MSG_INVALID_ID = 
			"Error: Index provided is invalid!";
	private int idx;
	private ArrayList<String> fields;
	private ArrayList<String> newValues;
	private boolean isSeries;
	
	public UpdateCommand(Calendar cal, IndexStore indexStore, 
						 int idx, ArrayList<String> fields, 
						 ArrayList<String> newValues, boolean isSeries) {
		this.cal = cal;
		this.indexStore = indexStore;
		this.idx = idx;
		this.fields = fields;
		this.newValues = newValues;
		this.isSeries = isSeries;
	}
	
	@Override
	public Result execute() {
		saveCommand();
		
		if (isEvent()) {
			return executeUpdateEvent();
		} else if (isFloatingTask()) {
			return executeUpdateFloating();
		} else if (isTask()){
			return executeUpdateTask();
		} else {
			return handleInvalidUpdate();
		}
	}
	
	private Result executeUpdateEvent() {
		return cal.updateEvent(idx, fields, newValues, isSeries);
	}
	
	private Result executeUpdateFloating() {
		return cal.updateFloatingTask(idx, fields, newValues, isSeries);
	}
	
	private Result executeUpdateTask() {
		return cal.updateTask(idx, fields, newValues, isSeries);
	}
	
	private Result handleInvalidUpdate() {
		return new Result(MSG_INVALID_ID, false, null);
	}
	
	private boolean isEvent() {
		return indexStore.isEvent(idx);
	}
	
	private boolean isFloatingTask() {
		return indexStore.isFloatingTask(idx);
	}
	
	private boolean isTask() {
		return indexStore.isTask(idx);
	}
	
	private void saveCommand() {
		cal.saveCmd((Command) new UpdateCommand(cal, indexStore, idx, 
												fields, newValues, 
												isSeries));
	}
		
}
```
###### Tempo\Data\Event.java
``` java
	public void update(String field, String newValue) {
		switch(field) {
			case PARAM_NAME: 
				setName(newValue);
				break;
			case PARAM_START_DATE:
				newValue = CommandParser.formatDate(newValue);
				setStartDate(newValue);
				break;
			case PARAM_START_TIME:
				newValue = CommandParser.formatTime(newValue);
				setStartTime(newValue);
				break;
			case PARAM_END_DATE:
				newValue = CommandParser.formatDate(newValue);
				setEndDate(newValue);
				break;
			case PARAM_END_TIME:
				newValue = CommandParser.formatTime(newValue);
				setEndTime(newValue);
				break;
		}
	}
	
	private void setName(String newName) {
		this.name = newName;
	}
	
	private void setStartDateTime(String start){
		try {
			startDateTime = dateFormatter.parse(start);
		} catch (ParseException e) {
			System.out.println("Unable to format Start Date/Time!");
		}
	}
	
	
	private void setStartDate(String newStartDate) {
		String startTime = getStartTime();
		String newStartDateTime = newStartDate + DATE_DELIMETER + startTime;
		setStartDateTime(newStartDateTime);
	}
	
	private void setStartTime(String newStartTime) {
		String startDate = getStartDate();
		String newStartDateTime = startDate + DATE_DELIMETER + newStartTime;
		setStartDateTime(newStartDateTime);
	}
	
	private void setEndDateTime(String end) {
		try {
			endDateTime = dateFormatter.parse(end);
		} catch (ParseException e) {
			System.out.println("Unable to format End Date/Time!");
		}
	}
	
	private void setEndDate(String newEndDate) {
		String endTime = getEndTime();
		String newEndDateTime = newEndDate + DATE_DELIMETER + endTime;
		setEndDateTime(newEndDateTime);
	}
	
	private void setEndTime(String newEndTime) {
		String endDate = getEndDate();
		String newEndDateTime = endDate + DATE_DELIMETER + newEndTime;
		setEndDateTime(newEndDateTime);
	}
	
```
###### Tempo\Logic\Calendar.java
``` java
package Tempo.Logic;

import java.io.*;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.*;

import Tempo.Commands.*;
import Tempo.Data.*;
import Tempo.Storage.*;

public class Calendar {
	private static Calendar instance = new Calendar();
	private static IndexStore indexStore;
	private static CalendarImporter importer;
	private static CalendarExporter exporter;
	private static Display display;

	private static Stack<Command> undoHistory;
	private static Stack<Command> redoHistory;
	private static Stack<Command> cmdHistory;

	private static final String MSG_WARNING_CLASH = 
			"Warning: this event clashes with another event.\n"
			+ "Enter 'undo' if you would like to revoke the previous operation.";
	private static final String MSG_ERROR_INVALID_FIELD = 
			"Error: You have input an invalid field.\n"
			+ "Pleae refer to the 'help' menu for reference.";

	private static final String CMD_ADD_EVENT = "add event %1$s";
	private static final String CMD_ADD_RECURR_EVENT = "add recurring event %1$s";
	private static final String CMD_ADD_TASK = "add task %1$s";
	private static final String CMD_ADD_RECURR_TASK = "add recurring task %1$s";
	private static final String CMD_ADD_FLOATING = "add floating task %1$s";

	private static final String CMD_REMOVE_EVENT = "remove event %1$s";
	private static final String CMD_REMOVE_TASK = "remove task %1$s";
	private static final String CMD_REMOVE_FLOATING = "remove floating task %1$s";

	private static final String CMD_EDIT_FILENAME = "renamed file as <%1$s>.";

	private static final String CMD_UPDATE_EVENT = "update event %1$s";
	private static final String CMD_UPDATE_TASK = "update task %1$s";
	private static final String CMD_UPDATE_FLOATING = "update floating task %1$s";

	private static final String CMD_DONE_TASK = "done task %1$s";
	private static final String CMD_DONE_FLOATING = "done floating task %1$s";

	private static final String CMD_UNDONE_TASK = "undone task %1$s";
	private static final String CMD_UNDONE_FLOATING = "undone floating task %1$s";

	private static final String CMD_UNDO = "undo";
	private static final String CMD_UNDO_CLEAR = "clear %1$s";

	private static final String CMD_REDO = "redo";

	private static final String CMD_SEARCH = "search %1$s";

	private static final String CMD_CLEAR = "%1$s has been cleared.";

	private static final String KEY_EVENTS = "events";
	private static final String KEY_TASKS = "tasks";
	private static final String KEY_FLOATING = "floating tasks";
	private static final String KEY_DAILY = "daily";
	private static final String KEY_WEEKLY = "weekly";
	private static final String KEY_MONTHLY = "monthly";
	private static final String KEY_ANNUALLY = "annually";
	private static final String KEY_YEARLY = "yearly";

	private static final String KEY_EVENTS_BEST_MATCHES = "eventsBestMatches";
	private static final String KEY_EVENTS_ALTERNATIVE_MATCHES = "eventsAlternativeMatches";
	private static final String KEY_TASKS_BEST_MATCHES = "tasksBestMatches";
	private static final String KEY_TASKS_ALTERNATIVE_MATCHES = "tasksAlternativeMatches";
	private static final String KEY_FLOATING_TASKS_BEST_MATCHES = "floatingTasksBestMatches";
	private static final String KEY_FLOATING_TASKS_ALTERNATIVE_MATCHES = 
								"floatingTasksAlternativeMatches";

	private static final String PARAM_NAME = "name";
	private static final String PARAM_START_DATE = "start date";
	private static final String PARAM_START_TIME = "start time";
	private static final String PARAM_END_DATE = "end date";
	private static final String PARAM_END_TIME = "end time";
	private static final String PARAM_DUE = "due";
	private static final String PARAM_REPEAT = "repeat";
	private static final String PARAM_RECURRING = "recurring";

	private static final String KEY_BEST_MATCHES = "bestMatches";
	private static final String KEY_ALTERNATIVE_MATCHES = "alternativeMatches";

	private static final String FIELD_START_DATE = "start date";
	private static final String FIELD_START_TIME = "start time";
	private static final String FIELD_END_DATE = "end date";
	private static final String FIELD_END_TIME = "end time";

	public static final long MILLISECONDS_A_DAY = 86400000;
	public static final long MILLISECONDS_A_WEEK = 604800000;
	public static final String DATE_DELIMETER = "/";

	private boolean isUndoCmd = false;
	private boolean isUpdateRecurringCmd = false;

	private String fileName;

	private ArrayList<CalendarObject> eventsList;
	private ArrayList<CalendarObject> tasksList;
	private ArrayList<CalendarObject> floatingTasksList;

	private Calendar() {
		initialiseLists();
		initialiseIndexStore();
		initialiseStorage();
		initialiseDisplay();
		initialiseStacks();
	}
	
	private void initialiseLists() {
		eventsList = new ArrayList<CalendarObject>();
		tasksList = new ArrayList<CalendarObject>();
		floatingTasksList = new ArrayList<CalendarObject>();
	}
	
	private void initialiseIndexStore() {
		indexStore = IndexStore.getInstance();
	}
	
	private void initialiseStorage() {
		importer = CalendarImporter.getInstance();
		exporter = CalendarExporter.getInstance();
	}
	
	private void initialiseDisplay() {
		display = Display.getInstance();
	}
	
	private void initialiseStacks() {
		undoHistory = new Stack<Command>();
		redoHistory = new Stack<Command>();
		cmdHistory = new Stack<Command>();
	}

```
###### Tempo\Logic\Calendar.java
``` java
	private void addNewUndoClear() {
		Command newUndo = (Command) new UndoClear(eventsList, tasksList, floatingTasksList);
		undoHistory.add(newUndo);
	}

```
###### Tempo\Logic\Calendar.java
``` java
	public Result addEvent(String name, String start, String end) {
		boolean hasClash = false;
		int newEventIndex = indexStore.getNewId();
		int newSeriesIndex = indexStore.getNewSeriesId();
		Event newEvent = new Event(newEventIndex, newSeriesIndex, name, start, end);
		if (hasClash(newEvent)) {
			hasClash = true;
		}
		eventsList.add(newEvent);
		indexStore.addEvent(newEventIndex, newEvent);
		sortEvents();
		exportToFile();

		String cmd = String.format(CMD_ADD_EVENT, name);

		if (hasClash) {
			return new Result(cmd, MSG_WARNING_CLASH, true, 
							  putInHashMap(KEY_EVENTS, eventsList));
		}
		
		addNewUndoAdd(newEventIndex, true, false, false);

		clearRedoHistory();

		return new Result(cmd, true, putInHashMap(KEY_EVENTS, eventsList));
	}

	public Result addBackEvent(Event newEvent) {
		eventsList.add(newEvent);
		indexStore.addEvent(newEvent.getIndex(), newEvent);
		sortEvents();

		String name = newEvent.getName();
		String cmd = String.format(CMD_ADD_EVENT, name);

		return new Result(cmd, true, putInHashMap(KEY_EVENTS, eventsList));
	}

```
###### Tempo\Logic\Calendar.java
``` java
	public Result addBackAll(ArrayList<CalendarObject> events, ArrayList<CalendarObject> tasks,
							 ArrayList<CalendarObject> floatingTasks) {
		eventsList = events;
		tasksList = tasks;
		floatingTasksList = floatingTasks;
		indexStore.initialiseStore(events, tasks, floatingTasks);

		HashMap<String, ArrayList<CalendarObject>> listsMap;
		listsMap = new HashMap<String, ArrayList<CalendarObject>>();
		listsMap.put(KEY_EVENTS, events);
		listsMap.put(KEY_TASKS, tasks);
		listsMap.put(KEY_FLOATING, floatingTasks);

		String cmd = String.format(CMD_UNDO_CLEAR, fileName);
		return new Result(cmd, true, listsMap);
	}

```
###### Tempo\Logic\Calendar.java
``` java
	public Result addBackRecurrEvent(ArrayList<CalendarObject> events) {
		String name = new String();

		for (int i = 0; i < events.size(); i++) {
			Event newEvent = (Event) events.get(i);
			int index = newEvent.getIndex();
			eventsList.add(newEvent);
			indexStore.addEvent(index, newEvent);
			name = newEvent.getName();
		}

		sortEvents();
		exportToFile();

		String cmd = String.format(CMD_ADD_RECURR_EVENT, name);
		return new Result(cmd, true, putInHashMap(KEY_EVENTS, eventsList));
	}

	public Result addTask(String name, String dueDate) {
		int newTaskIndex = indexStore.getNewId();
		int newSeriesIndex = indexStore.getNewSeriesId();
		Task newTask = new Task(newTaskIndex, newSeriesIndex, name, dueDate);
		tasksList.add(newTask);
		indexStore.addTask(newTaskIndex, newTask);
		sortTasks();
		exportToFile();

		addNewUndoAdd(newTaskIndex, false, true, false);
		clearRedoHistory();

		String cmd = String.format(CMD_ADD_TASK, name);
		return new Result(cmd, true, putInHashMap(KEY_TASKS, tasksList));
	}
	
	public Result addBackTask(Task newTask) {
		tasksList.add(newTask);
		indexStore.addTask(newTask.getIndex(), newTask);
		sortTasks();

		String name = newTask.getName();
		String cmd = String.format(CMD_ADD_TASK, name);

		return new Result(cmd, true, putInHashMap(KEY_TASKS, tasksList));
	}

```
###### Tempo\Logic\Calendar.java
``` java
	public Result addBackRecurrTask(ArrayList<CalendarObject> tasks) {
		String name = new String();

		for (int i = 0; i < tasks.size(); i++) {
			Task newTask = (Task) tasks.get(i);
			int index = newTask.getIndex();
			tasksList.add(newTask);
			indexStore.addTask(index, newTask);
			name = newTask.getName();
		}

		sortTasks();
		exportToFile();

		String cmd = String.format(CMD_ADD_RECURR_TASK, name);
		return new Result(cmd, true, putInHashMap(KEY_TASKS, tasksList));
	}

	public Result addFloatingTask(String name) {
		int newTaskIndex = indexStore.getNewId();
		int newSeriesIndex = indexStore.getNewSeriesId();
		FloatingTask newFloatingTask = new FloatingTask(newTaskIndex, newSeriesIndex, name);
		indexStore.addTask(newTaskIndex, newFloatingTask);
		floatingTasksList.add(newFloatingTask);
		exportToFile();
		
		addNewUndoAdd(newTaskIndex, false, false, false);
		clearRedoHistory();

		String cmd = String.format(CMD_ADD_FLOATING, name);
		return new Result(cmd, true, putInHashMap(KEY_FLOATING, floatingTasksList));
	}

	public Result addBackFloating(FloatingTask newTask) {
		floatingTasksList.add(newTask);
		indexStore.addTask(newTask.getIndex(), newTask);

		String name = newTask.getName();
		String cmd = String.format(CMD_ADD_FLOATING, name);

		return new Result(cmd, true, putInHashMap(KEY_FLOATING, floatingTasksList));
	}
	
	private void addNewUndoAdd(int index, boolean isEvent, boolean isTask, 
			   boolean isSeries ) {
		if (!isUpdateRecurringCmd) {
			Command newUndo = (Command) new UndoAdd(index, isEvent, isTask, isSeries);
			undoHistory.add(newUndo);
		}
	}

	public Result removeEvent(int idx, boolean isSeries) {
		ArrayList<CalendarObject> oldEvents = new ArrayList<CalendarObject>();
		String eventName = new String();
		int seriesIndex = -1;

		for (int i = 0; i < eventsList.size(); i++) {
			Event currEvent = (Event) eventsList.get(i);
			if (currEvent.getIndex() == idx) {
				oldEvents.add(currEvent);
				seriesIndex = currEvent.getSeriesIndex();
				eventName = currEvent.getName();
				indexStore.removeEvent(currEvent.getIndex());
				eventsList.remove(i);
				break;
			}
		}

```
###### Tempo\Logic\Calendar.java
``` java
		if (isSeries) {
			addNewUndoRemoveRecurr(oldEvents, true);
		} else {
			Event event = (Event) oldEvents.get(0);
			addNewUndoRemoveEvent(event);
		}
		clearRedoHistory();

		String cmd = String.format(CMD_REMOVE_EVENT, eventName);
		return new Result(cmd, true, putInHashMap(KEY_EVENTS, eventsList));
	}
	
	public Result removeTask(int idx, boolean isSeries) {
		ArrayList<CalendarObject> oldTasks = new ArrayList<CalendarObject>();
		String taskName = new String();
		int seriesIndex = -1;

		for (int i = 0; i < tasksList.size(); i++) {
			Task currTask = (Task) tasksList.get(i);
			if (currTask.getIndex() == idx) {
				oldTasks.add(currTask);
				seriesIndex = currTask.getSeriesIndex();
				taskName = currTask.getName();
				indexStore.removeTask(currTask.getIndex());
				tasksList.remove(i);
				break;
			}
		}

```
###### Tempo\Logic\Calendar.java
``` java
		if (isSeries) {
			addNewUndoRemoveRecurr(oldTasks, false);
		} else {
			Task task = (Task) oldTasks.get(0);
			addNewUndoRemoveTask(task);
		}

		clearRedoHistory();

		String cmd = String.format(CMD_REMOVE_TASK, taskName);
		return new Result(cmd, true, putInHashMap(KEY_TASKS, tasksList));
	}

	

	public Result removeFloatingTask(int idx, boolean isSeries) {
		String taskName = new String();
		FloatingTask oldTask = null;

		for (int i = 0; i < floatingTasksList.size(); i++) {
			FloatingTask currFloating = (FloatingTask) floatingTasksList.get(i);
			if (currFloating.getIndex() == idx) {
				oldTask = currFloating;
				taskName = currFloating.getName();
				indexStore.removeTask(currFloating.getIndex());
				floatingTasksList.remove(i);
				break;
			}
		}
		exportToFile();
		addNewUndoRemoveFloating(oldTask);
		clearRedoHistory();

		String cmd = String.format(CMD_REMOVE_FLOATING, taskName);
		return new Result(cmd, true, putInHashMap(KEY_FLOATING, tasksList));
	}
	
	private void addNewUndoRemoveRecurr(ArrayList<CalendarObject> prevList, 
	        boolean isEventsSeries) {
		if (!isUpdateRecurringCmd) {
			Command newUndo = (Command) new UndoRemove(prevList, true);
			undoHistory.add(newUndo);
		}
	}
	
	private void addNewUndoRemoveEvent(Event event) {
		if (!isUpdateRecurringCmd) {
			Command newUndo = (Command) new UndoRemove(event);
			undoHistory.add(newUndo);
		}
	}
	
	private void addNewUndoRemoveTask(Task task) {
		if (!isUpdateRecurringCmd) {
			Command newUndo = (Command) new UndoRemove(task);
			undoHistory.add(newUndo);
		}
	}
	
	private void addNewUndoRemoveFloating(FloatingTask task) {
		if (!isUpdateRecurringCmd) {
			Command newUndo = (Command) new UndoRemove(task);
			undoHistory.add(newUndo);
		}
	}

	public Result updateEvent(int idx, ArrayList<String> fields, 
							  ArrayList<String> newValues, boolean isSeries) {
		boolean hasClash = false;
		ArrayList<CalendarObject> oldEvents = new ArrayList<CalendarObject>();

		int arrayListIndex = getArrayListIndexOfEvent(idx);
		Event eventToUpdate = (Event) eventsList.get(arrayListIndex);
		int seriesIndex = eventToUpdate.getSeriesIndex();
		Event oldEvent = copyEvent(eventToUpdate);
		int recurringFieldIdx = -1;

		String name = eventToUpdate.getName();
		String cmd = String.format(CMD_UPDATE_EVENT, name);

		boolean isUpdateRecurring = false;

		if (hasInvalidFields(fields, KEY_EVENTS)) {
			return new Result(cmd, MSG_ERROR_INVALID_FIELD, false, null);
		}

		isUpdateRecurring = hasUpdateRecurring(fields);

		for (int i = 0; i < fields.size(); i++) {
			if (!(fields.get(i).equals(PARAM_RECURRING) 
				|| fields.get(i).equals(PARAM_REPEAT))) {
				eventToUpdate.update(fields.get(i), newValues.get(i));
			} else {
				recurringFieldIdx = i;
			}
			if (!hasClash && hasChangedTime(fields.get(i)) && hasClash(eventToUpdate)) {
				hasClash = true;
			}
		}

		//@author A0125962B
		if (isSeries) {
			for (int i = 0; i < eventsList.size(); i++) {
				Event currEvent = (Event) eventsList.get(i);
				if (currEvent.getSeriesIndex() == seriesIndex) {
					oldEvents.add(copyEvent(currEvent));
					for (int j = 0; j < fields.size(); j++) {
						if ((fields.get(j).equals(PARAM_RECURRING) 
							|| fields.get(j).equals(PARAM_REPEAT))) {
							continue;
						}
						currEvent.update(fields.get(j), newValues.get(j));
						if (!hasClash && hasChangedTime(fields.get(j)) 
							&& hasClash(currEvent)) {
							hasClash = true;
						}
					}

				}
			}
		}

		if (isUpdateRecurring) {
			if (recurringFieldIdx != -1) {
				try {
					if (hasOnlyOneField(fields) && !isSeries) {
						for (int i = 0; i < eventsList.size(); i++) {
							Event currEvent = (Event) eventsList.get(i);
							if (currEvent.getSeriesIndex() == seriesIndex) {
								oldEvents.add(copyEvent(currEvent));
							}
						}
					}
					ArrayList<String> recurringParams = CommandParser
							.getRecurrArgs(newValues.get(recurringFieldIdx));
					Event tempEvent = copyEvent(eventToUpdate);
					isUpdateRecurringCmd = true;
					removeEvent(eventToUpdate.getIndex(), true);
					String nameStr = tempEvent.getName();
					String startDateTimeStr = tempEvent.getStartDateTimeSimplified();
					String endDateTimeStr = tempEvent.getEndDateTimeSimplified();
					String recurrTypeStr = recurringParams.get(0);
					String recurrEndStr = recurringParams.get(1);
					addRecurringEvent(nameStr, startDateTimeStr, endDateTimeStr, 
									  recurrTypeStr, recurrEndStr);
					isUpdateRecurringCmd = false;
				} catch (Exception e) {
					return new Result(cmd, MSG_ERROR_INVALID_FIELD, false, null);
				}
			}
		}
		
		exportToFile();

```
###### Tempo\Logic\Calendar.java
``` java
		if (isSeries || isUpdateRecurring) {
			addNewUndoUpdateRecurr(oldEvents, true);
		} else {
			addNewUndoUpdateEvent(oldEvent);
		}
		clearRedoHistory();

		if (hasClash) {
			return new Result(cmd, MSG_WARNING_CLASH, true, 
							  putInHashMap(KEY_EVENTS, eventsList));
		}

		return new Result(cmd, true, putInHashMap(KEY_EVENTS, eventsList));
	}
	


	private Event copyEvent(Event event) {
		int idx = event.getIndex();
		int seriesId = event.getSeriesIndex();
		String eventName = event.getName();
		String startDateTime = event.getStartDateTimeSimplified();
		String endDateTime = event.getEndDateTimeSimplified();
		return new Event(idx, seriesId, eventName, startDateTime, endDateTime);
	}

	public Result updateTask(int idx, ArrayList<String> fields, ArrayList<String> newValues, 
							 boolean isSeries) {
		ArrayList<CalendarObject> oldTasks = new ArrayList<CalendarObject>();

		int arrayListIndex = getArrayListIndexOfTask(idx);
		Task taskToUpdate = (Task) tasksList.get(arrayListIndex);
		int seriesIndex = taskToUpdate.getSeriesIndex();
		Task oldTask = copyTask(taskToUpdate);

		String name = taskToUpdate.getName();
		String cmd = String.format(CMD_UPDATE_TASK, name);

		boolean isUpdateRecurring = false;
		int recurringFieldIdx = -1;

		if (hasInvalidFields(fields, KEY_TASKS)) {
			return new Result(cmd, MSG_ERROR_INVALID_FIELD, false, null);
		}

		isUpdateRecurring = hasUpdateRecurring(fields);

		for (int i = 0; i < fields.size(); i++) {
			if (!(fields.get(i).equals(PARAM_RECURRING) 
				|| fields.get(i).equals(PARAM_REPEAT))) {
				taskToUpdate.update(fields.get(i), newValues.get(i));
			} else {
				recurringFieldIdx = i;
			}
		}

```
###### Tempo\Logic\Calendar.java
``` java
		if (isSeries || isUpdateRecurring) {
			addNewUndoUpdateRecurr(oldTasks, false);
		} else {
			addNewUndoUpdateTask(oldTask);
		}


		clearRedoHistory();

		return new Result(cmd, true, putInHashMap(KEY_TASKS, tasksList));
	}

	private Task copyTask(Task task) {
		int idx = task.getIndex();
		int seriesIdx = task.getSeriesIndex();
		String taskName = task.getName();
		String taskDoneStatus = String.valueOf(task.isDone());
		String dueDate = task.getDueDateSimplified();
		return new Task(idx, seriesIdx, taskName, taskDoneStatus, dueDate);
	}

	public Result updateFloatingTask(int idx, ArrayList<String> fields, 
									 ArrayList<String> newValues, boolean isSeries) {

		int arrayListIndex = getArrayListIndexOfFloatingTask(idx);
		FloatingTask taskToUpdate = (FloatingTask) floatingTasksList.get(arrayListIndex);
		FloatingTask oldTask = copyFloatingTask(taskToUpdate);

		String name = taskToUpdate.getName();
		String cmd = String.format(CMD_UPDATE_FLOATING, name);

		boolean updateDue = false;
		int dueFieldIdx = -1;

```
###### Tempo\Logic\Calendar.java
``` java
		exportToFile();
		addNewUndoUpdateFloating(oldTask);
		clearRedoHistory();

		return new Result(cmd, true, putInHashMap(KEY_FLOATING, floatingTasksList));
	}
	
	private void addNewUndoUpdateRecurr(ArrayList<CalendarObject> prevList, 
			boolean isEventsSeries) {
		Command newUndo = (Command) new UndoUpdate(prevList, isEventsSeries);
		undoHistory.add(newUndo);
	}
	
	private void addNewUndoUpdateEvent(Event event) {
		Command newUndo = (Command) new UndoUpdate(event);
		undoHistory.add(newUndo);
	}
	
	private void addNewUndoUpdateTask(Task task) {
		Command newUndo = (Command) new UndoUpdate(task);
		undoHistory.add(newUndo);
	}
	
	private void addNewUndoUpdateFloating(FloatingTask task) {
		Command newUndo = (Command) new UndoUpdate(task);
		undoHistory.add(newUndo);
	}

	private FloatingTask copyFloatingTask(FloatingTask task) {
		int idx = task.getIndex();
		int seriesIdx = task.getSeriesIndex();
		String taskName = task.getName();
		String taskDoneStatus = String.valueOf(task.isDone());
		return new FloatingTask(idx, seriesIdx, taskName, taskDoneStatus);
	}

```
###### Tempo\Logic\Calendar.java
``` java
	public Result markTaskAsUndone(int idx) {
		if (isFloatingTask(idx)) {
			return markFloatingTaskAsDone(idx);
		}

		int arrayListIndex = getArrayListIndexOfTask(idx);
		Task taskToMark = (Task) tasksList.get(arrayListIndex);

		String taskName = taskToMark.getName();

		if (!taskToMark.isDone()) {
			return new Result(CMD_UNDONE_TASK, false, null);
		} else {
			taskToMark.markAsUndone();
			addNewUndoDoneOrUndone(idx, false, false);
			clearRedoHistory();
			exportToFile();
			String cmd = String.format(CMD_UNDONE_TASK, taskName);
			return new Result(cmd, true, putInHashMap(KEY_TASKS, tasksList));
		}
	}
	
	public Result markFloatingTaskAsUndone(int idx) {
		int arrayListIndex = getArrayListIndexOfFloatingTask(idx);
		FloatingTask taskToMark = (FloatingTask) floatingTasksList.get(arrayListIndex);

		String taskName = taskToMark.getName();

		if (!taskToMark.isDone()) {
			return new Result(CMD_UNDONE_FLOATING, false, null);
		} else {
			taskToMark.markAsUndone();
			addNewUndoDoneOrUndone(idx, true, false);
			clearRedoHistory();
			exportToFile();
			String cmd = String.format(CMD_UNDONE_FLOATING, taskName);
			return new Result(cmd, true, putInHashMap(KEY_FLOATING, floatingTasksList));
		}
	}
	
	private void addNewUndoDoneOrUndone(int index, boolean isFloating, boolean isDoneCmd) {
		Command newUndo = (Command) new UndoDone(index, isFloating, isDoneCmd);
		undoHistory.add(newUndo);
	}

	public Result undo() {
		if (undoHistory.isEmpty()) {
			return new Result(CMD_UNDO, false, null);
		}
		isUndoCmd = true;
		Result result = undoHistory.pop().execute();
		if (!cmdHistory.isEmpty()) {
			redoHistory.add(cmdHistory.pop());
		}
		exportToFile();
		isUndoCmd = false;
		return result;
	}

	public void removeLastUndo() {
		undoHistory.pop();
	}

	public void addToUndoHistory(Command cmd) {
		undoHistory.add(cmd);
	}

	public Result redo() {
		if (redoHistory.isEmpty()) {
			return new Result(CMD_REDO, false, null);
		}
		Result result = redoHistory.pop().execute();
		exportToFile();

		return result;
	}

	public void saveCmd(Command cmd) {
		cmdHistory.add(cmd);
	}

	private void clearRedoHistory() {
		if (!isUndoCmd) {
			System.out.println("Clearing redo history..."); // debug
			redoHistory.clear();
		}
	}

```
###### Tempo\Logic\Calendar.java
``` java
	private int getArrayListIndexOfEvent(int id) {
		int index = 0;

		for (int i = 0; i < eventsList.size(); i++) {
			Event currEvent = (Event) eventsList.get(i);
			if (currEvent.getIndex() == id) {
				index = i;
			}
		}

		return index;
	}

	private int getArrayListIndexOfTask(int id) {
		int index = 0;

		for (int i = 0; i < tasksList.size(); i++) {
			Task currTask = (Task) tasksList.get(i);
			if (currTask.getIndex() == id) {
				index = i;
			}
		}

		return index;
	}

	private int getArrayListIndexOfFloatingTask(int id) {
		int index = 0;

		for (int i = 0; i < floatingTasksList.size(); i++) {
			FloatingTask currFloatingTask = (FloatingTask) floatingTasksList.get(i);
			if (currFloatingTask.getIndex() == id) {
				index = i;
			}
		}

		return index;
	}

	private boolean isFloatingTask(int id) {
		return indexStore.isFloatingTask(id);
	}

	private HashMap<String, ArrayList<CalendarObject>> putInHashMap(String key, 
											ArrayList<CalendarObject> value) {
		HashMap<String, ArrayList<CalendarObject>> map;
		map = new HashMap<String, ArrayList<CalendarObject>>();
		map.put(key, value);
		return map;
	}

	private boolean hasOnlyOneField(ArrayList<String> fields) {
		return fields.size() == 1;
	}

```
###### Tempo\Logic\Calendar.java
``` java
	private boolean hasClash(Event event) {
		for (int i = 0; i < eventsList.size(); i++) {
			Event currEvent = (Event) eventsList.get(i);
			if (!event.equals(currEvent) && event.clashesWith(currEvent)) {
				return true;
			}
		}
		return false;
	}

	private boolean hasChangedTime(String field) {
		field = field.trim();
		return (field.equals(FIELD_START_DATE) || field.equals(FIELD_START_TIME) 
				|| field.equals(FIELD_END_DATE) || field.equals(FIELD_END_TIME));
	}
}
```
###### Tempo\Logic\IndexStore.java
``` java
package Tempo.Logic;

import java.util.*;

import Tempo.Data.CalendarObject;
import Tempo.Data.Event;
import Tempo.Data.FloatingTask;
import Tempo.Data.Task;

public class IndexStore {
	private static IndexStore instance = new IndexStore();
	
	private static int nextUnusedPriId;
	private static int nextUnusedSecId;
	private static LinkedList<Integer> recycledPriId;
	private static LinkedList<Integer> recycledSeriesId;
	public static HashMap<Integer, CalendarObject> events;
	public static HashMap<Integer, CalendarObject> tasks;
	
	private IndexStore() {
		resetStore();	
	}
	
	public static IndexStore getInstance() {
		return instance;
	}
	
	public void resetStore(){
		nextUnusedPriId = 0;
		nextUnusedSecId = 0;
		recycledPriId = new LinkedList<Integer>();
		recycledSeriesId = new LinkedList<Integer>();
		events = new HashMap<Integer, CalendarObject>();
		tasks = new HashMap<Integer, CalendarObject>();
	}
		
	public void initialiseStore(ArrayList<CalendarObject> eventsList, 
								ArrayList<CalendarObject> tasksList, 
			  					ArrayList<CalendarObject> floatingTasksList) {
		initialiseEventsMap(eventsList);
		initialiseTasksMap(tasksList, floatingTasksList);
		updateRecycledId();
		updateRecycledSecId();
	}
	
	private void initialiseEventsMap(ArrayList<CalendarObject> eventsList) {
		for (int i = 0; i < eventsList.size(); i++) {
			Event currEvent = (Event) eventsList.get(i);
			addEvent(currEvent.getIndex(), currEvent);
			updateNextUnusedId(currEvent.getIndex());
			updateNextUnusedSecId(currEvent.getSeriesIndex());
		}
	}
	
	private void initialiseTasksMap(ArrayList<CalendarObject> tasksList, 
									ArrayList<CalendarObject> floatingTasksList) {
		for (int i = 0; i < tasksList.size(); i++) {
			Task currTask = (Task) tasksList.get(i);
			addTask(currTask.getIndex(), currTask);
			updateNextUnusedId(currTask.getIndex());
			updateNextUnusedSecId(currTask.getSeriesIndex());
		}
		
		for (int i = 0; i < floatingTasksList.size(); i++) {
			FloatingTask currTask = (FloatingTask) floatingTasksList.get(i);
			addTask(currTask.getIndex(), currTask);
			updateNextUnusedId(currTask.getIndex());
		}
	}
	
	private void updateNextUnusedId(int idx) {
		if (idx >= nextUnusedPriId) {
			nextUnusedPriId = idx + 1;
		}
	}
	
	private void updateNextUnusedSecId(int idx) {
		if (idx >= nextUnusedSecId) {
			nextUnusedSecId = idx + 1;
		}
	}
	
	private void updateRecycledId() {
		for (int i = 0; i < nextUnusedPriId; i++) {
			if (!isUsedId(i)) {
				recycledPriId.add(i);
			}
		}
		Collections.sort(recycledPriId);
	}
	
	private void updateRecycledSecId() {
		for (Integer key : events.keySet()) {
			Event currEvent = (Event) events.get(key);
			int currId = currEvent.getSeriesIndex();
			if (!recycledSeriesId.contains(currId)) {
				recycledSeriesId.add(currId);
			}
		}
		
		for (Integer key : tasks.keySet()) {
			FloatingTask currTask = (FloatingTask) tasks.get(key);
			int currId = currTask.getSeriesIndex();
			if (!recycledSeriesId.contains(currId)) {
				recycledSeriesId.add(currId);
			}
		}
		Collections.sort(recycledSeriesId);
	}
	
	private boolean isUsedId(int idx) {
		return (events.containsKey(idx) || tasks.containsKey(idx));
	}
	
	public void addEvent(int index, Event newEvent) {
		if (recycledPriId.contains(index)) {
			recycledPriId.remove(index);
		}
		if (recycledSeriesId.contains(newEvent.getSeriesIndex())) {
			recycledSeriesId.remove(newEvent.getSeriesIndex());
		}
		events.put(index, newEvent);
	}
	
	public void addTask(int index, FloatingTask newTask) {
		if (recycledPriId.contains(index)) {
			recycledPriId.remove(index);
		}
		if (recycledSeriesId.contains(newTask.getSeriesIndex())) {
			recycledSeriesId.remove(index);
		}
		tasks.put(index, newTask);
	}
	
	public void removeEvent(int index) {
		Event eventToRemove = (Event) events.get(index);
		int seriesId = eventToRemove.getSeriesIndex();
		recycledSeriesId.add(seriesId);
		events.remove(index);
		recycledPriId.add(index);
		Collections.sort(recycledSeriesId);
		Collections.sort(recycledPriId);
	}
	
	public void removeTask(int index) {
		FloatingTask taskToRemove = (FloatingTask) tasks.get(index);
		int seriesId = taskToRemove.getSeriesIndex();
		recycledSeriesId.add(seriesId);
		tasks.remove(index);
		recycledPriId.add(index);
		Collections.sort(recycledSeriesId);
		Collections.sort(recycledPriId);
	}
	
	public void replaceEvent(int index, Event event) {
		removeEvent(index);
		addEvent(index, event);
		removeRecycledId(index);
	}
	
	public void replaceTask(int index, FloatingTask task) {
		removeTask(index);
		addTask(index, task);
		removeRecycledId(index);
	}
	
	public int getNewId() {
		int id;
		if (recycledPriId.isEmpty()) {
			id = nextUnusedPriId;
			updateNextUnusedId(id);
		} else {
			id = recycledPriId.remove();
		}
		
		return id;
	}
	
	public int getNewSeriesId() {
		int id;
		if (recycledSeriesId.isEmpty()) {
			id = nextUnusedSecId;
			updateNextUnusedSecId(id);
		} else {
			id = recycledSeriesId.remove();
		}
		
		return id;
	}
	
	public void removeRecycledId(int index) {
		for (int i = 0; i < recycledPriId.size(); i++) {
			if (recycledPriId.get(i) == index) {
				recycledPriId.remove(i);
				break;
			}
		}
	}
	
	public boolean isEvent(int id) {
		return events.containsKey(id);
	}
	
	public boolean isFloatingTask(int id) {
		FloatingTask task = (FloatingTask) getTaskById(id);
		return task.isFloatingTask();
	}
	
	public boolean isTask(int id) {
		return (!isEvent(id) && !isFloatingTask(id));
	}
	
	public CalendarObject getEventById(int id) {
		return events.get(id);
	}
	
	public CalendarObject getTaskById(int id) {
		return tasks.get(id);
	}
}
```
