# A0125962B
###### Tempo\Commands\ClearCommand.java
``` java
package Tempo.Commands;

import Tempo.Logic.Calendar;

public class ClearCommand implements Command{
	private Calendar cal;
	
	public ClearCommand(Calendar cal){
		this.cal = cal;
	}
	
	public Result execute() {
		saveCommand();
		return cal.clearFile();
	}
	
	private void saveCommand() {
		cal.saveCmd((Command) new ClearCommand(cal));
	}

}
```
###### Tempo\Commands\Command.java
``` java
package Tempo.Commands;

public interface Command {	   
	   Result execute();
}
```
###### Tempo\Commands\EditFilenameCommand.java
``` java
package Tempo.Commands;

import Tempo.Logic.Calendar;

public class EditFileNameCommand implements Command{
	private static final String command = "rename file as %1$s";
	
	private Calendar cal;
	private String fileName;
	
	public EditFileNameCommand(Calendar cal, String fileName){
		this.cal = cal;
		this.fileName = fileName;
	}
	
	public Result execute() {
		saveCommand();
		String originalFileName = cal.getFilename();
		boolean isSuccess = cal.setFilename(fileName);
		String returnCommand = String.format(command, fileName);
		
		if(isSuccess){
			cal.addToUndoHistory((Command) new UndoEditFileName(originalFileName));
			return new Result(returnCommand,isSuccess,null);
	
		}else{
			cal.setFilename(originalFileName);
			return new Result(returnCommand,isSuccess,null);
		}
	}
	
	private void saveCommand() {
		cal.saveCmd((Command) new EditFileNameCommand(cal, fileName));
	}

}
```
###### Tempo\Commands\ExitCommand.java
``` java
package Tempo.Commands;

public class ExitCommand implements Command{
	private static final String MSG_BYE = "Thank you for using Tempo!";
	
	public Result execute() {
		System.out.println(MSG_BYE);
		System.exit(0);
		return null;
	}
	
}
```
###### Tempo\Commands\HelpCommand.java
``` java
package Tempo.Commands;

import Tempo.Logic.Display;

public class HelpCommand implements Command{
	private static String cmd = "help";
	
	public Result execute() {
		return new Result(cmd,Display.getManual(),true,null);
	}
}
```
###### Tempo\Commands\Result.java
``` java
package Tempo.Commands;

import java.util.ArrayList;
import java.util.HashMap;

import Tempo.Data.*;

public class Result {
	private String cmdPeformed;
	private String warning;
	private boolean isSuccess;
	private boolean isDisplayResult;
	private HashMap<String, ArrayList<CalendarObject>> results;
	
	public Result(String commandPerformed, boolean isSuccess, 
				HashMap<String, ArrayList<CalendarObject>> result) {
		this.cmdPeformed = commandPerformed;
		this.warning = null;
		this.isDisplayResult = false;
		this.isSuccess = isSuccess;
		this.results = result;
	}
	
	public Result(String commandPerformed, String warning, 
				boolean isSuccess, 
				HashMap<String, ArrayList<CalendarObject>> result) {
		this.cmdPeformed = commandPerformed;
		this.warning = warning;
		this.isDisplayResult = false;
		this.isSuccess = isSuccess;
		this.results = result;
	}
	
	public Result(String cmdPerformed, boolean isDisplayResult, 
				boolean isSuccess, 
				HashMap<String, ArrayList<CalendarObject>> result){
		this.cmdPeformed = cmdPerformed;
		this.warning = null;
		this.isDisplayResult = isDisplayResult;
		this.isSuccess = isSuccess;
		this.results = result;
	}
	
	public String getCmdPerformed(){
		return cmdPeformed;
	}
	
	public boolean hasWarning(){
		if(warning != null){
			return true;
		}else{
			return false;
		}
	}
	
	public String getWarning(){
		return warning;
	}
	
	public boolean isDisplayResult(){
		return isDisplayResult;
	}
	
	public boolean isSuccess(){
		return isSuccess;
	}
	
	public HashMap<String, ArrayList<CalendarObject>> getResults(){
		return results;
	}
	
	public void setCommand(String newCommand) {
		cmdPeformed = newCommand;
	}
	
}
```
###### Tempo\Commands\ToggleDoneCommand.java
``` java
package Tempo.Commands;

import Tempo.Logic.Calendar;
import Tempo.Logic.*;

public class ToggleDoneCommand implements Command {
	private Calendar cal;
	private IndexStore indexStore;
	private int idx;
	private boolean isDoneCmd;
	
	private static final String MSG_ERROR = 
			"Error: Index provided is not a valid task!";

	public ToggleDoneCommand(Calendar cal, IndexStore indexStore, 
							int idx, boolean isDoneCmd) {
		this.cal = cal;
		this.indexStore = indexStore;
		this.idx = idx;
		this.isDoneCmd = isDoneCmd;
	}
	
	public Result execute() {
		saveCommand();
		
		if(isTask() || isFloatingTask()){
			return executeDoneOrUndoneCmd();
		} else {
			return handleInvalidDone();
		}
	}
	
	private Result executeDoneOrUndoneCmd() {
		if(isDoneCmd){
			return cal.markTaskAsDone(idx);
		} else {
			return cal.markTaskAsUndone(idx);
		}
	}
	
	private Result handleInvalidDone() {
		return new Result(MSG_ERROR, false, null);
	}
	
	private boolean isFloatingTask(){
		return indexStore.isFloatingTask(idx);
	}

	private boolean isTask() {
		return indexStore.isTask(idx);
	}
	
	private void saveCommand() {
		cal.saveCmd((Command) new ToggleDoneCommand(cal, indexStore, 
													idx, isDoneCmd));
	}
}
```
###### Tempo\Commands\UndoEditFileName.java
``` java
package Tempo.Commands;

import Tempo.Logic.Calendar;

public class UndoEditFileName implements Command {
	private static Calendar cal = Calendar.getInstance();
	private static final String CMD_UNDO = "undo <rename file as %1$s>";
	private String fileName;
	private String originalFileName;
	
	public UndoEditFileName(String fileName) {
		this.fileName = fileName;
		originalFileName = cal.getFilename();
	}

	public Result execute() {
		Result result = executeUndoEditFileName();
		String cmd = String.format(CMD_UNDO, originalFileName);
		result.setCommand(cmd);
		return result;
	}
	
	private Result executeUndoEditFileName() {
		return cal.editFilename(fileName);
	}

}
```
###### Tempo\Data\CalendarObject.java
``` java
package Tempo.Data;

public interface CalendarObject {
	
}
```
###### Tempo\Data\Event.java
``` java
package Tempo.Data;

import java.text.*;
import java.util.*;

import Tempo.Logic.CommandParser;

public class Event implements CalendarObject, Comparable<Event>{
	protected Date startDateTime;
	protected Date endDateTime;
	protected int index;
	protected int seriesIndex;
	protected String name;
	
	private static final String DELIMETER = "!!";
	private static final String DATE_DELIMETER = "/";
	private static final String PARAM_NAME = "name";
	private static final String PARAM_START_DATE = "start date";
	private static final String PARAM_START_TIME = "start time";
	private static final String PARAM_END_DATE = "end date";
	private static final String PARAM_END_TIME = "end time";
	
	private SimpleDateFormat dateFormatter = new SimpleDateFormat("dd/MM/yyyy/HH:mm");
	
	public Event(int index, int seriesIndex, String name, String start, String end){
		this.name = name;
		this.index = index;
		this.seriesIndex = seriesIndex;		
		setStartDateTime(start.trim());
		setEndDateTime(end.trim());
		}
	
```
###### Tempo\Data\Event.java
``` java
	public int getIndex() {
		return index;
	}
	
	public int getSeriesIndex(){
		return seriesIndex;
	}
	
	public String getName(){
		return name;
	}
	
	public String getStartDate(){
		SimpleDateFormat formatter = new SimpleDateFormat("dd/MM/yyyy");
		return formatter.format(startDateTime);
	}
	
	public String getStartTime(){
		SimpleDateFormat formatter = new SimpleDateFormat("HH:mm");
		return formatter.format(startDateTime);
	}
	
	public String getStartDateTime(){
		SimpleDateFormat formatter = new SimpleDateFormat("EEEE, dd/MM/yyyy HH:mm");
		return formatter.format(startDateTime);
	}
	
	public String getStartDateTimeSimplified(){
		SimpleDateFormat formatter = new SimpleDateFormat("dd/MM/yyyy/HH:mm");
		return formatter.format(startDateTime);
	}
	
	public String getEndDate(){
		SimpleDateFormat formatter = new SimpleDateFormat("dd/MM/yyyy");
		return formatter.format(endDateTime);
	}
	
	public String getEndTime(){
		SimpleDateFormat formatter = new SimpleDateFormat("HH:mm");
		return formatter.format(endDateTime);
	}
	
	public String getEndDateTime(){
		SimpleDateFormat formatter = new SimpleDateFormat("EEEE, dd/MM/yyyy HH:mm");
		return formatter.format(endDateTime);
	}
	
	public String getEndDateTimeSimplified(){
		SimpleDateFormat formatter = new SimpleDateFormat("dd/MM/yyyy/HH:mm");
		return formatter.format(endDateTime);
	}

	
	public long getStartTimeInMilli(){
		return startDateTime.getTime();
	}
	
	public long getEndTimeInMilli(){
		return endDateTime.getTime();
	}
	
	public int compareTo(Event e){
		if(this.getStartTimeInMilli() < e.getStartTimeInMilli()){
			return -1;
		}else if(this.getStartTimeInMilli() == e.getStartTimeInMilli()){
			return 0;
		}else if(this.getStartTimeInMilli() > e.getStartTimeInMilli()){
			return 1;
		}
		return 0;
	}
	
	public String toString(){
		return getIndex() + DELIMETER + getSeriesIndex()+ DELIMETER + getName() + DELIMETER + getStartDate() + DATE_DELIMETER + getStartTime() + DELIMETER + getEndDate()+ DATE_DELIMETER +getEndTime(); 
	}
	
	public boolean clashesWith(Event e){
		if(isBefore(e) || isAfter(e)){
			return false;
		}else{
			return true;
		}
	}
	
	private boolean isBefore(Event e) {
		return this.getEndTimeInMilli() <= e.getStartTimeInMilli();
	}
	
	private boolean isAfter(Event e) {
		return this.getStartTimeInMilli() >= e.getEndTimeInMilli();
	}
}
```
###### Tempo\Data\FloatingTask.java
``` java
package Tempo.Data;

public class FloatingTask implements CalendarObject{
	protected String name;
	protected boolean done;
	protected int index;
	protected int seriesIndex;
	
	private static final String DELIMETER = "!!";
	
	public FloatingTask(int index, String name, String done){
		this.name = name;
		this.index = index;
		this.name = name;
		this.done = false;
	}
	
	public FloatingTask(int index, int seriesIndex, String name){
		this.name = name;
		this.index = index;
		this.name = name;
		this.done = false;
	}
	
	public FloatingTask(int index, int seriesIndex, String name, String done) {
		this.name = name;
		this.index = index;
		this.seriesIndex = seriesIndex;
		this.done = Boolean.parseBoolean(done);
	}
	
	public void update(String field, String newValue) {
		if (field.equals("name")) {
			setName(newValue);
		}
	}
	
	public void setName(String newName) {
		name = newName;
	}
	
	public int getIndex() {
		return index;
	}
	
	public int getSeriesIndex(){
		return seriesIndex;
	}

	public String getName() {
		return name;
	}

	public boolean isDone() {
		return done;
	}

	public void markAsDone() {
		done = true;
	}
	
	public void markAsUndone() {
		done = false;
	}
	
	public boolean isFloatingTask() {
		return true;
	}
	
	public String toString(){
		return getIndex() + DELIMETER + getSeriesIndex() + DELIMETER + getName() + DELIMETER + isDone();
	}
}
```
###### Tempo\Data\Task.java
``` java
package Tempo.Data;

import java.util.*;

import Tempo.Logic.CommandParser;

import java.text.*;

public class Task extends FloatingTask implements Comparable<Task> {
	protected Date _dueDate;
	private static final String DELIMETER = "!!";
	
	public Task(int index, int seriesIndex, String name, String done, String dueDateString){
		super(index, seriesIndex, name, done);
		setDueDate(dueDateString);
	}
	
	public Task(int index, int seriesIndex, String name, String dueDateString) {
		super(index, seriesIndex, name);
		setDueDate(dueDateString);
	}
	
	private void setDueDate(String dueDateString) {
		SimpleDateFormat formatter = new SimpleDateFormat("dd/MM/yyyy");
		
		try {
			_dueDate = formatter.parse(dueDateString);
		} catch (ParseException e) {
			System.out.println("Unable to format date");
		}
	}
	
	@Override
	public void update(String field, String newValue) {
		switch(field) {
			case "name": 
				super.setName(newValue);
				break;
			case "due":
				newValue = CommandParser.formatDate(newValue);
				setDueDate(newValue);
				break;
		}
	}
	
	@Override
	public boolean isFloatingTask() {
		return false;
	}
		
	public String getDueDate(){
		//SimpleDateFormat formatter = new SimpleDateFormat("EEEE, dd/MM/yyyy");
		SimpleDateFormat formatter = new SimpleDateFormat("EEEE, dd/MM/yyyy");
		return formatter.format(_dueDate);
	}
	
	public String getDueDateSimplified(){
		//For toString() only
		SimpleDateFormat formatter = new SimpleDateFormat("dd/MM/yyyy");
		return formatter.format(_dueDate);
	}
	
	public long getDueDateTimeInMilli(){
		return _dueDate.getTime();
	}
	
	public int compareTo(Task t) {
		if(this.getDueDateTimeInMilli() < t.getDueDateTimeInMilli()){
			return -1;
		}else if(this.getDueDateTimeInMilli() == t.getDueDateTimeInMilli()){
			return 0;
		}else if (this.getDueDateTimeInMilli() > t.getDueDateTimeInMilli()){
			return 1;
		}
		return 0;
	}
	
	public String toString(){
		return super.toString() + DELIMETER + getDueDateSimplified();
	}
}
```
###### Tempo\Logic\Calendar.java
``` java
	public static Calendar getInstance() {
		return instance;
	}

	public void createFile(String fileName) {
		this.fileName = fileName;
		File file = new File(fileName);
		if (file.exists()) {
			importFromFile();
			indexStore.initialiseStore(eventsList, tasksList, floatingTasksList);
		}
	}

	public Result editFilename(String fileName) {
		clearRedoHistory();

		if (setFilename(fileName)) {
			String cmd = String.format(CMD_EDIT_FILENAME, fileName);
			return new Result(cmd, true, null);
		} else {
			return new Result(null, false, null);
		}
	}

	public boolean setFilename(String fileName) {
		clearRedoHistory();

		boolean isSuccess = false;
		this.fileName = fileName;
		if (exporter.setFileName(fileName)) {
			exporter.export();
			isSuccess = true;
		}
		return isSuccess;
	}

	public String getFilename() {
		return fileName;
	}

	public Result clearFile() {
		addNewUndoClear();
		clearCalendar();

		exportToFile();
		String returnString = String.format(CMD_CLEAR, fileName);

		clearRedoHistory();

		return new Result(returnString, true, true, null);
	}
	
```
###### Tempo\Logic\Calendar.java
``` java
	public void clearCalendar() {
		eventsList = new ArrayList<CalendarObject>();
		tasksList = new ArrayList<CalendarObject>();
		floatingTasksList = new ArrayList<CalendarObject>();

		indexStore.resetStore();
	}

```
###### Tempo\Logic\Calendar.java
``` java
	public Result addRecurringEvent(String name, String start, String end, 
									String recurringType, String recurringEnd) {
		int newEventIndex = indexStore.getNewId();
		int newSeriesIndex = indexStore.getNewSeriesId();
		Event newEvent = new Event(newEventIndex, newSeriesIndex, name, start, end);
		eventsList.add(newEvent);
		indexStore.addEvent(newEventIndex, newEvent);

		String split[] = start.split(DATE_DELIMETER);
		String timeString = split[split.length - 1];

		long startEndDiff = getStartEndDiff(start, end);

		// Gets the list of recurring dates;
		ArrayList<String> recurringDates = processRecurringDates(start, recurringEnd, 
																 recurringType);

		for (String dates : recurringDates) {
			newEventIndex = indexStore.getNewId();

			String newStart = dates + DATE_DELIMETER + timeString;
			String newEnd = null;

			if (startEndDiff != -1) {
				newEnd = getNewEndString(newStart, startEndDiff);
			}

			newEvent = new Event(newEventIndex, newSeriesIndex, name, newStart, newEnd);
			eventsList.add(newEvent);
			indexStore.addEvent(newEventIndex, newEvent);
		}

		sortEvents();
		exportToFile();
		
		addNewUndoAdd(newEventIndex, true, false, true);
		clearRedoHistory();

		String cmd = String.format(CMD_ADD_RECURR_EVENT, name);
		return new Result(cmd, true, putInHashMap(KEY_EVENTS, eventsList));
	}

```
###### Tempo\Logic\Calendar.java
``` java
	private long getStartEndDiff(String start, String end) {
		if (end != null) {
			try {
				SimpleDateFormat df = new SimpleDateFormat("dd/MM/yyyy/HH:mm");
				Date startDate = df.parse(start);
				Date endDate = df.parse(end);

				long startDateMilli = startDate.getTime();
				long endDateMilli = endDate.getTime();

				long startEndDiff = endDateMilli - startDateMilli;
				return startEndDiff;
			} catch (Exception e) {
				return -1;
			}
		}
		return -1;
	}

	private String getNewEndString(String newStart, long startEndDiff) {
		SimpleDateFormat df = new SimpleDateFormat("dd/MM/yyyy/HH:mm");
		try {
			long newStartDateLong = df.parse(newStart).getTime();
			long newEndDateLong = newStartDateLong + startEndDiff;
			String newEnd = df.format(newEndDateLong);
			return newEnd;
		} catch (Exception e) {
			return null;
		}
	}

```
###### Tempo\Logic\Calendar.java
``` java
	public Result addRecurringTask(String name, String dueDate, String recurringType, 
								   String recurringEnd) {
		int newTaskIndex = indexStore.getNewId();
		int newSeriesIndex = indexStore.getNewSeriesId();
		Task newTask = new Task(newTaskIndex, newSeriesIndex, name, dueDate);
		tasksList.add(newTask);
		indexStore.addTask(newTaskIndex, newTask);

		// Gets the list of recurring dates;
		ArrayList<String> recurringDates = processRecurringDates(dueDate, recurringEnd, 
																 recurringType);

		for (String dates : recurringDates) {
			newTaskIndex = indexStore.getNewId();
			newTask = new Task(newTaskIndex, newSeriesIndex, name, dates);
			tasksList.add(newTask);
			indexStore.addTask(newTaskIndex, newTask);
		}

		sortTasks();
		exportToFile();
		
		addNewUndoAdd(newTaskIndex, false, true, true);
		clearRedoHistory();

		String cmd = String.format(CMD_ADD_RECURR_TASK, name);
		return new Result(cmd, true, putInHashMap(KEY_TASKS, tasksList));
	}


```
###### Tempo\Logic\Calendar.java
``` java
		if (isSeries) {
			for (int i = 0; i < eventsList.size(); i++) {
				Event currEvent = (Event) eventsList.get(i);
				if (currEvent.getSeriesIndex() == seriesIndex) {
					oldEvents.add(currEvent);
					indexStore.removeEvent(currEvent.getIndex());
					eventsList.remove(i);
					i--;
					continue;
				}
			}
		}
		exportToFile();

```
###### Tempo\Logic\Calendar.java
``` java
		if (isSeries) {
			for (int i = 0; i < tasksList.size(); i++) {
				Task currTask = (Task) tasksList.get(i);
				if (currTask.getSeriesIndex() == seriesIndex) {
					oldTasks.add(currTask);
					indexStore.removeTask(currTask.getIndex());
					tasksList.remove(i);
					i--;
				}
			}
		}

		exportToFile();

```
###### Tempo\Logic\Calendar.java
``` java
		if (isSeries) {
			for (int i = 0; i < tasksList.size(); i++) {
				Task currTask = (Task) tasksList.get(i);
				if (currTask.getSeriesIndex() == seriesIndex) {
					oldTasks.add(copyTask(currTask));
					for (int j = 0; j < fields.size(); j++) {
						if ((fields.get(j).equals(PARAM_RECURRING) 
							|| fields.get(j).equals(PARAM_REPEAT))) {
							continue;
						}
						currTask.update(fields.get(j), newValues.get(j));
					}
				}
			}
		}

		if (isUpdateRecurring) {
			if (recurringFieldIdx != -1) {
				try {
					if (hasOnlyOneField(fields) && !isSeries) {
						for (int i = 0; i < tasksList.size(); i++) {
							Task currTask = (Task) tasksList.get(i);
							if (currTask.getSeriesIndex() == seriesIndex) {
								oldTasks.add(copyTask(currTask));
							}
						}
					}
					ArrayList<String> recurringParams = CommandParser
							.getRecurrArgs(newValues.get(recurringFieldIdx));

					Task tempTask = copyTask(taskToUpdate);
					isUpdateRecurringCmd = true;
					removeTask(taskToUpdate.getIndex(), true);
					String nameStr = tempTask.getName();
					String dueDateStr = tempTask.getDueDateSimplified();
					String recurrTypeStr = recurringParams.get(0);
					String recurrEndStr = recurringParams.get(1);
					addRecurringTask(nameStr, dueDateStr, recurrTypeStr, recurrEndStr);
					isUpdateRecurringCmd = false;
				} catch (Exception e) {
					return new Result(cmd, MSG_ERROR_INVALID_FIELD, false, null);
				}
			}
		}

		exportToFile();

```
###### Tempo\Logic\Calendar.java
``` java
		if (hasInvalidFields(fields, KEY_FLOATING)) {
			return new Result(cmd, MSG_ERROR_INVALID_FIELD, false, null);
		}

		updateDue = hasUpdateDue(fields);

		for (int i = 0; i < fields.size(); i++) {
			if (fields.get(i).equals(PARAM_DUE)) {
				dueFieldIdx = i;
			}
		}

		for (int i = 0; i < fields.size(); i++) {
			if (!fields.get(i).equals(PARAM_DUE)) {
				taskToUpdate.update(fields.get(i), newValues.get(i));
			} else {
				dueFieldIdx = i;
			}
		}

		if (updateDue) {
			FloatingTask tempTask = copyFloatingTask(taskToUpdate);
			removeFloatingTask(idx, true);
			addTask(tempTask.getName(), newValues.get(dueFieldIdx));
		}

```
###### Tempo\Logic\Calendar.java
``` java
	private boolean hasUpdateRecurring(ArrayList<String> fields) {
		for (String field : fields) {
			if (field.equals(PARAM_RECURRING) || field.equals(PARAM_REPEAT)) {
				return true;
			}
		}
		return false;
	}

	private boolean hasUpdateDue(ArrayList<String> fields) {
		for (String field : fields) {
			if (field.equals(PARAM_DUE)) {
				return true;
			}
		}
		return false;
	}

	private boolean hasInvalidFields(ArrayList<String> fields, String key) {
		if (key.equals(KEY_EVENTS)) {
			for (String field : fields) {
				if (isValidEventField(field)) {
					// DO NOTHING
				} else {
					return true;
				}
			}
		} else if (key.equals(KEY_TASKS)) {
			for (String field : fields) {
				if (isValidTaskField(field)) {
					// DO NOTHING
				} else {
					return true;
				}
			}
		} else if (key.equals(KEY_FLOATING)) {
			for (String field : fields) {
				if (isValidFloatingTaskField(field)) {
					// DO NOTHING
				} else {
					return true;
				}
			}
		} else {
			return true;
		}

		return false;
	}

	private boolean isValidEventField(String field) {
		switch (field) {
			case PARAM_NAME :
			case PARAM_START_DATE :
			case PARAM_START_TIME :
			case PARAM_END_DATE :
			case PARAM_END_TIME :
			case PARAM_RECURRING :
			case PARAM_REPEAT :
				return true;
			default :
				return false;
		}
	}

	private boolean isValidTaskField(String field) {
		switch (field) {
			case PARAM_NAME :
			case PARAM_DUE :
			case PARAM_RECURRING :
			case PARAM_REPEAT :
				return true;
			default :
				return false;
		}
	}

	private boolean isValidFloatingTaskField(String field) {
		switch (field) {
			case PARAM_NAME :
			case PARAM_DUE :
				return true;
			default :
				return false;
		}
	}

	public Result markTaskAsDone(int idx) {
		if (isFloatingTask(idx)) {
			return markFloatingTaskAsDone(idx);
		}

		int arrayListIndex = getArrayListIndexOfTask(idx);
		Task taskToMark = (Task) tasksList.get(arrayListIndex);

		String taskName = taskToMark.getName();

		if (taskToMark.isDone()) {
			return new Result(CMD_DONE_TASK, false, null);
		} else {
			taskToMark.markAsDone();
			addNewUndoDoneOrUndone(idx, false, true);
			clearRedoHistory();
			exportToFile();
			String cmd = String.format(CMD_DONE_TASK, taskName);
			return new Result(cmd, true, putInHashMap(KEY_TASKS, tasksList));
		}
	}

	public Result markFloatingTaskAsDone(int idx) {
		int arrayListIndex = getArrayListIndexOfFloatingTask(idx);
		FloatingTask taskToMark = (FloatingTask) floatingTasksList.get(arrayListIndex);

		String taskName = taskToMark.getName();

		if (taskToMark.isDone()) {
			return new Result(CMD_DONE_FLOATING, false, null);
		} else {
			taskToMark.markAsDone();
			addNewUndoDoneOrUndone(idx, true, true);
			clearRedoHistory();
			exportToFile();
			String cmd = String.format(CMD_DONE_FLOATING, taskName);
			return new Result(cmd, true, putInHashMap(KEY_FLOATING, floatingTasksList));
		}
	}

```
###### Tempo\Logic\Calendar.java
``` java
	public Result search(String arguments) {
		String bestMatchRegex = generateBestMatchRegex(arguments);
		String alternativeMatchRegex = generateAlternativeMatchRegex(arguments);

		ArrayList<CalendarObject> eventsToSearch = copyEventsList();
		ArrayList<CalendarObject> tasksToSearch = copyTasksList();
		ArrayList<CalendarObject> floatingTasksToSearch = copyFloatingTasksList();

		HashMap<String, ArrayList<CalendarObject>> results = 
				new HashMap<String, ArrayList<CalendarObject>>();

		HashMap<String, ArrayList<CalendarObject>> eventSearchResult = 
				getMatches(eventsToSearch, bestMatchRegex, alternativeMatchRegex);
		HashMap<String, ArrayList<CalendarObject>> taskSearchResult = 
				getMatches(tasksToSearch, bestMatchRegex, alternativeMatchRegex);
		HashMap<String, ArrayList<CalendarObject>> floatingTaskSearchResult = 
				getMatches(floatingTasksToSearch, bestMatchRegex, alternativeMatchRegex);

		ArrayList<CalendarObject> eventsBestMatch = eventSearchResult.get(KEY_BEST_MATCHES);
		ArrayList<CalendarObject> eventsAlternativeMatch = eventSearchResult
														   .get(KEY_ALTERNATIVE_MATCHES);

		ArrayList<CalendarObject> tasksBestMatch = taskSearchResult.get(KEY_BEST_MATCHES);
		ArrayList<CalendarObject> tasksAlternativeMatch = taskSearchResult
														  .get(KEY_ALTERNATIVE_MATCHES);

		ArrayList<CalendarObject> floatingTaskBestMatch = floatingTaskSearchResult
														  .get(KEY_BEST_MATCHES);
		ArrayList<CalendarObject> floatingTasksAlternativeMatch = floatingTaskSearchResult
															.get(KEY_ALTERNATIVE_MATCHES);

		results.put(KEY_EVENTS_BEST_MATCHES, eventsBestMatch);
		results.put(KEY_EVENTS_ALTERNATIVE_MATCHES, eventsAlternativeMatch);
		results.put(KEY_TASKS_BEST_MATCHES, tasksBestMatch);
		results.put(KEY_TASKS_ALTERNATIVE_MATCHES, tasksAlternativeMatch);
		results.put(KEY_FLOATING_TASKS_BEST_MATCHES, floatingTaskBestMatch);
		results.put(KEY_FLOATING_TASKS_ALTERNATIVE_MATCHES, floatingTasksAlternativeMatch);

		String cmd = String.format(CMD_SEARCH, arguments);

		String displayString = display
				.formatSearchResults(eventsBestMatch, eventsAlternativeMatch, tasksBestMatch, 
									 tasksAlternativeMatch, floatingTaskBestMatch, 
									 floatingTasksAlternativeMatch);

		Result result = new Result(cmd, displayString, true, results);
		return result;
	}

	private String generateBestMatchRegex(String args) {
		String[] splittedArgs = args.split("\\s+");

		String regex = "(?i:.*";

		for (String s : splittedArgs) {
			regex += s + ".*";
		}

		regex += ")";
		return regex;
	}

	private String generateAlternativeMatchRegex(String args) {
		String[] splittedArgs = args.split("\\s+");

		String regex = "(?i:.*";

		for (int i = 0; i < splittedArgs.length - 1; i++) {
			regex += splittedArgs[i] + ".*|.*";
		}

		if (!(splittedArgs.length - 1 < 0)) {
			regex += splittedArgs[splittedArgs.length - 1] + ".*";
		}

		regex += ")";
		return regex;
	}

	private ArrayList<CalendarObject> copyEventsList() {
		ArrayList<CalendarObject> returnArray = new ArrayList<CalendarObject>();

		for (CalendarObject obj : eventsList) {
			returnArray.add(obj);
		}
		return returnArray;
	}

	private ArrayList<CalendarObject> copyTasksList() {
		ArrayList<CalendarObject> returnArray = new ArrayList<CalendarObject>();

		for (CalendarObject obj : tasksList) {
			returnArray.add(obj);
		}
		return returnArray;
	}

	private ArrayList<CalendarObject> copyFloatingTasksList() {
		ArrayList<CalendarObject> returnArray = new ArrayList<CalendarObject>();

		for (CalendarObject obj : floatingTasksList) {
			returnArray.add(obj);
		}
		return returnArray;
	}

	private HashMap<String, ArrayList<CalendarObject>> getMatches
		(ArrayList<CalendarObject> objectsToMatch, String bestMatchRegex, 
		 String alternativeMatchRegex) {
		HashMap<String, ArrayList<CalendarObject>> returnHashMap = 
				new HashMap<String, ArrayList<CalendarObject>>();
		ArrayList<CalendarObject> bestMatches = new ArrayList<CalendarObject>();
		ArrayList<CalendarObject> alternativeMatches = new ArrayList<CalendarObject>();

		while (objectsToMatch.size() > 0) {
			CalendarObject currObject = objectsToMatch.get(0);

			if (currObject.toString().matches(bestMatchRegex)) {
				bestMatches.add(currObject);
				objectsToMatch.remove(0);
			} else if (currObject.toString().matches(alternativeMatchRegex)) {
				alternativeMatches.add(currObject);
				objectsToMatch.remove(0);
			} else {
				objectsToMatch.remove(0);
			}
		}

		returnHashMap.put(KEY_BEST_MATCHES, bestMatches);
		returnHashMap.put(KEY_ALTERNATIVE_MATCHES, alternativeMatches);

		return returnHashMap;
	}

	public ArrayList<CalendarObject> getEventsList() {
		return eventsList;
	}

	public ArrayList<CalendarObject> getTasksList() {
		return tasksList;
	}

	public ArrayList<CalendarObject> getFloatingTasksList() {
		return floatingTasksList;
	}

	public void exportToFile() {
		// System.out.println("Exporting: " + _fileName);
		exporter.setFileName(fileName);
		exporter.export();
		// System.out.println("Export Successful!");
	}

	public void importFromFile() {
		System.out.println("Importing: " + fileName);
		if (importer.importFromFile(fileName)) {
			eventsList = importer.getEventsList();
			tasksList = importer.getTasksList();
			floatingTasksList = importer.getFloatingTasksList();

			sortEvents();
			sortTasks();

			System.out.println("Import Sucessful!");
		} else {
			System.out.println("Import failed!");
		}
	}

```
###### Tempo\Logic\Calendar.java
``` java
	private ArrayList<String> processRecurringDates(String start, String recurringEnd, 
													String recurringType) {
		switch (recurringType.toLowerCase()) {
			case KEY_DAILY :
				return getDailyRecurringDates(start, recurringEnd);

			case KEY_WEEKLY :
				return getWeeklyRecurringDates(start, recurringEnd);

			case KEY_MONTHLY :
				return getMonthlyRecurringDates(start, recurringEnd);

			case KEY_ANNUALLY :
			case KEY_YEARLY :
				return getAnnualRecurringDates(start, recurringEnd);

			default :
				return null;
		}
	}

	private ArrayList<String> getDailyRecurringDates(String start, String end) {
		Date startDate = null;
		Date endDate = null;
		long startMilli = -1;
		long endMilli = -1;

		ArrayList<String> returnArray = new ArrayList<String>();

		try {
			startDate = parseDate(start);

			if (end != null) {
				endDate = parseDate(end);
			}
		} catch (Exception e) {
			return null;
		}

		startMilli = dateToMilli(startDate);

		if (endDate != null) {
			endMilli = dateToMilli(endDate);
		}

		if (endDate != null) {
			while ((endMilli - startMilli) > 0) {
				startMilli += MILLISECONDS_A_DAY;
				String currDate = formatDateMilli(startMilli);
				returnArray.add(currDate);
			}
		} else {
			for (int i = 0; i < 20; i++) {
				startMilli += MILLISECONDS_A_DAY;
				String currDate = formatDateMilli(startMilli);
				returnArray.add(currDate);
			}
		}
		return returnArray;
	}

	private ArrayList<String> getWeeklyRecurringDates(String start, String end) {
		Date startDate = null;
		Date endDate = null;
		long startMilli = -1;
		long endMilli = -1;

		ArrayList<String> returnArray = new ArrayList<String>();

		try {
			startDate = parseDate(start);

			if (end != null) {
				endDate = parseDate(end);
			}
		} catch (Exception e) {
			return null;
		}

		startMilli = dateToMilli(startDate);

		if (endDate != null) {
			endMilli = dateToMilli(endDate);
		}

		if (endDate != null) {
			while ((endMilli - startMilli) > MILLISECONDS_A_WEEK) {
				startMilli += MILLISECONDS_A_WEEK;
				String currDate = formatDateMilli(startMilli);
				returnArray.add(currDate);
			}
		} else {
			for (int i = 0; i < 20; i++) {
				startMilli += MILLISECONDS_A_WEEK;
				String currDate = formatDateMilli(startMilli);
				returnArray.add(currDate);
			}
		}

		return returnArray;
	}

	private ArrayList<String> getMonthlyRecurringDates(String start, String end) {
		ArrayList<String> returnArray = new ArrayList<String>();

		String[] splitStart = start.split(DATE_DELIMETER);
		String startDay = splitStart[0];
		int startMonth = Integer.parseInt(splitStart[1]);
		int startYear = Integer.parseInt(splitStart[2]);
		String startTime = splitStart[3];

		Date startDate = null;
		Date endDate = null;

		long startMilli = -1;
		long endMilli = -1;

		try {
			startDate = parseDate(start);

			if (end != null) {
				endDate = parseDate(end);
			}
		} catch (Exception e) {
			return null;
		}

		startMilli = dateToMilli(startDate);
		if (endDate != null) {
			endMilli = dateToMilli(endDate);
		}

		if (endDate != null) {
			while ((endMilli - startMilli) > 0) {
				startMonth++;
				if (startMonth == 13) {
					startMonth = 1;
					startYear++;
				}

				String currDate = formatCurrDateString(startDay, String.valueOf(startMonth), 
													   String.valueOf(startYear), startTime);

				try {
					startMilli = dateToMilli(parseDate(currDate));
				} catch (ParseException e) {
					continue;
				}

				if (isValidDate(startMilli, endMilli)) {
					returnArray.add(formatDateMilli(startMilli));
				}
			}
		} else {
			for (int i = 0; i < 20; i++) {
				startMonth++;
				if (startMonth == 13) {
					startMonth = 1;
					startYear++;
				}

				String currDate = formatCurrDateString(startDay, String.valueOf(startMonth), 
													   String.valueOf(startYear), startTime);

				try {
					startMilli = dateToMilli(parseDate(currDate));
				} catch (ParseException e) {
					continue;
				}
				returnArray.add(formatDateMilli(startMilli));
			}
		}
		return returnArray;
	}

	private ArrayList<String> getAnnualRecurringDates(String start, String end) {
		ArrayList<String> returnArray = new ArrayList<String>();

		String[] splitStart = start.split(DATE_DELIMETER);
		String startDay = splitStart[0];
		String startMonth = splitStart[1];
		int startYear = Integer.parseInt(splitStart[2]);
		String startTime = splitStart[3];

		Date startDate = null;
		Date endDate = null;

		long startMilli = -1;
		long endMilli = -1;

		try {
			startDate = parseDate(start);

			if (end != null) {
				endDate = parseDate(end);
			}
		} catch (Exception e) {
			return null;
		}

		startMilli = dateToMilli(startDate);

		if (endDate != null) {
			endMilli = endDate.getTime();
		}

		if (endDate != null) {
			while ((endMilli - startMilli) > 0) {
				startYear++;
				String currDate = formatCurrDateString(startDay, startMonth, 
													   String.valueOf(startYear), startTime);
				try {
					startMilli = dateToMilli(parseDate(currDate));
				} catch (ParseException e) {
					continue;
				}
				if (isValidDate(startMilli, endMilli)) {
					returnArray.add(formatDateMilli(startMilli));
				}
			}
		} else {
			for (int i = 0; i < 20; i++) {
				startYear++;
				String currDate = formatCurrDateString(startDay, startMonth, 
													   String.valueOf(startYear), startTime);
				try {
					startMilli = dateToMilli(parseDate(currDate));
				} catch (ParseException e) {
					continue;
				}

				returnArray.add(formatDateMilli(startMilli));

			}
		}
		return returnArray;
	}

	private Date parseDate(String dateString) throws ParseException {
		SimpleDateFormat df = new SimpleDateFormat("dd/MM/yyyy");
		df.setLenient(false);
		return df.parse(dateString);
	}

	private String formatDateMilli(long date) {
		SimpleDateFormat df = new SimpleDateFormat("dd/MM/yyyy");
		df.setLenient(false);
		return df.format(date);
	}

	private long dateToMilli(Date date) {
		return date.getTime();
	}

	private String formatCurrDateString(String startDay, String startMonth, String startYear, 
										String startTime) {
		return startDay + DATE_DELIMETER + startMonth + DATE_DELIMETER + startYear 
				+ DATE_DELIMETER + startTime;
	}

	private boolean isValidDate(long currDate, long endDate) {
		if (currDate > endDate) {
			return false;
		} else {
			return true;
		}
	}

	public void sortEvents() {
		ArrayList<Event> events = new ArrayList<Event>();

		for (CalendarObject o : eventsList) {
			Event currEvent = (Event) o;
			events.add(currEvent);
		}

		Collections.sort(events);
		eventsList.clear();

		for (Event e : events) {
			eventsList.add(e);
		}
	}

	public void sortTasks() {
		ArrayList<Task> tasks = new ArrayList<Task>();

		for (CalendarObject o : tasksList) {
			Task currTask = (Task) o;
			tasks.add(currTask);
		}

		Collections.sort(tasks);
		tasksList.clear();

		for (Task t : tasks) {
			tasksList.add(t);
		}
	}

```
###### Tempo\Logic\CommandParser.java
``` java
package Tempo.Logic;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import com.joestelmach.natty.*;

import Tempo.Commands.AddCommand;
import Tempo.Commands.ClearCommand;
import Tempo.Commands.Command;
import Tempo.Commands.DisplayCommand;
import Tempo.Commands.EditFileNameCommand;
import Tempo.Commands.ToggleDoneCommand;
import Tempo.Commands.ExitCommand;
import Tempo.Commands.HelpCommand;
import Tempo.Commands.RedoCommand;
import Tempo.Commands.RemoveCommand;
import Tempo.Commands.SearchCommand;
import Tempo.Commands.UndoCommand;
import Tempo.Commands.UpdateCommand;

public class CommandParser {
	private static CommandParser instance = new CommandParser();

	private static final String COMMAND_ADD = "add";
	private static final String COMMAND_CREATE = "create";
	private static final String COMMAND_NEW = "new";

	private static final String COMMAND_REMOVE = "remove";
	private static final String COMMAND_DELETE = "delete";
	private static final String COMMAND_CANCEL = "cancel";

	private static final String COMMAND_UPDATE = "update";
	private static final String COMMAND_EDIT = "edit";
	private static final String COMMAND_CHANGE = "change";

	private static final String COMMAND_DONE = "done";
	private static final String COMMAND_COMPLETED = "completed";
	private static final String COMMAND_FINISHED = "finished";

	private static final String COMMAND_UNDONE = "undone";

	private static final String COMMAND_VIEW = "view";
	private static final String COMMAND_DISPLAY = "display";

	private static final String COMMAND_SEARCH = "search";
	private static final String COMMAND_FIND = "find";

	private static final String COMMAND_UNDO = "undo";

	private static final String COMMAND_REDO = "redo";

	private static final String COMMAND_FILENAME = "filename";

	private static final String COMMAND_CLEAR = "clear";

	private static final String COMMAND_HELP = "help";

	private static final String COMMAND_EXIT = "exit";

	private static final String KEY_DAY = "day";
	private static final String KEY_WEEK = "week";
	private static final String KEY_MONTH = "month";
	private static final String KEY_YEAR = "year";

	private static final String KEY_DAILY = "daily";
	private static final String KEY_WEEKLY = "weekly";
	private static final String KEY_MONTHLY = "monthly";
	private static final String KEY_ANNUALLY = "annually";

	private static final String KEY_EVENT = "event";
	private static final String KEY_TASK = "task";
	private static final String KEY_EVENTS = "events";
	private static final String KEY_TASKS = "tasks";
	private static final String KEY_UPCOMING_EVENTS = "upcoming events";
	private static final String KEY_UNDONE_TASKS = "undone tasks";
	private static final String KEY_MISSED_TASKS = "missed tasks";
	private static final String KEY_TODAY = "today";
	private static final String KEY_ALL = "all";

	private static final String DATE_DELIMETER = "/";

	private static final String REGEX_DATE = "(0?[1-9]|[12][0-9]|3[01])[/|.|-](0?[1-9]|1[012])[/|.|-]\\d{4}";
	private static final String REGEX_TIME = "(0?[0-9]|1[0-9]|2[0-3]):([0-5][0-9])";

	private static final String DATE_FORMAT_1 = "dd/MM/yyyy";
	private static final String DATE_FORMAT_2 = "dd-MM-yyyy";
	private static final String DATE_FORMAT_3 = "dd.MM.yyyy";

	private static final String TIME_FORMAT = "HH:mm";
	private static final String DATETIME_FORMAT = "dd/MM/yyyy/HH:mm";

	private Calendar calendar = Calendar.getInstance();
	private IndexStore indexStore = IndexStore.getInstance();
	private Display display = Display.getInstance();

	private CommandParser() {

	}

	public static CommandParser getInstance() {
		return instance;
	}

	public Command parse(String commandString) {
		String commandType = getCommandType(commandString);
		String arguments = getArguments(commandString);
		switch (commandType.toLowerCase()) {
			case COMMAND_ADD :
			case COMMAND_CREATE :
			case COMMAND_NEW :
				return processAddCommand(arguments);

			case COMMAND_REMOVE :
			case COMMAND_DELETE :
			case COMMAND_CANCEL :
				return processRemoveCommand(arguments);

			case COMMAND_UPDATE :
			case COMMAND_EDIT :
			case COMMAND_CHANGE :
				return processUpdateCommand(arguments);

			case COMMAND_DONE :
			case COMMAND_FINISHED :
			case COMMAND_COMPLETED :
				return processDoneCommand(arguments);

			case COMMAND_UNDONE :
				return processUndoneCommand(arguments);

			case COMMAND_VIEW :
			case COMMAND_DISPLAY :
				return processDisplayCommand(arguments);

			case COMMAND_SEARCH :
			case COMMAND_FIND :
				return processSearchCommand(arguments);

			case COMMAND_UNDO :
				return processUndoCommand();

			case COMMAND_REDO :
				return processRedoCommand();

			case COMMAND_FILENAME :
				return processFilenameCommand(arguments);

			case COMMAND_CLEAR :
				return processClearCommand();

			case COMMAND_HELP :
				return processHelpCommand();

			case COMMAND_EXIT :
				return processExitCommand();

			default :
				return null;
		}
	}

	private String getCommandType(String commandString) {
		return getFirstWord(commandString);
	}

	public String getArguments(String message) {
		return removeFirstWord(message);
	}

	private Command processAddCommand(String argumentString) {
		String addType = getFirstWord(argumentString);
		argumentString = removeFirstWord(argumentString);
		ArrayList<String> args = null;
		boolean isRecurring = false;
		ArrayList<String> recurringArgs = null;
		String recurringType = null;
		String recurringDate = null;

		Command command;

		if (argumentString.contains(" repeat ")) {
			String[] split = argumentString.split(" repeat ");
			String recurringArgsString = split[split.length - 1];
			argumentString = getArgumentString(argumentString);
			isRecurring = true;
			try {
				recurringArgs = getRecurrArgs(recurringArgsString);
			} catch (Exception e) {
				return new AddCommand(calendar, null, true, null, null);
			}

			recurringType = recurringArgs.get(0);
			recurringDate = recurringArgs.get(1);
		}

		if (addType.equalsIgnoreCase(KEY_EVENT)) {
			try {
				args = processAddEventCommand(argumentString);
			} catch (Exception e) {
				return new AddCommand(calendar, null, true, null, null);
			}
		} else if (addType.equalsIgnoreCase(KEY_TASK)) {
			try {
				args = processAddTaskCommand(argumentString);
			} catch (Exception e) {
				return new AddCommand(calendar, null, true, null, null);
			}
		}

		if (args == null) {
			command = new AddCommand(null, null);
		} else {
			command = new AddCommand(calendar, args, isRecurring, recurringType, recurringDate);
		}
		return command;
	}

	private ArrayList<String> processAddEventCommand(String argumentString) throws Exception {
		String nameString = "";
		String startDateString = null;
		String startTimeString = null;
		String endTimeString = null;
		Date startDateTime = null;
		Date endDateTime = null;
		String startDateTimeString = null;
		String endDateTimeString = null;

		ArrayList<String> returnList = new ArrayList<String>();

		if (argumentString.contains(" from ")) {
			nameString = getEventNameFrom(argumentString);
			argumentString = argumentString.split(nameString)[1].trim();

			DateGroup dateGroup = parseDateTimeString(nameString);
			
			if (dateGroup != null) {
				Date startDate = dateGroup.getDates().get(0);
				SimpleDateFormat formatDate = new SimpleDateFormat(DATE_FORMAT_1);
				startDateString = formatDate.format(startDate);
			}

			if (argumentString.contains(" to ")) {
				String[] startEndTime = argumentString.split(" to ");

				endDateTimeString = startEndTime[1];
				startDateTimeString = removeFirstWord(startEndTime[0]);

				startDateTime = getDateTime(startDateTimeString);
				endDateTime = getDateTime(endDateTimeString);

			} else {
				endDateTime = null;
				startDateTimeString = removeFirstWord(argumentString).trim();
				startDateTime = getDateTime(startDateTimeString);
			}
		} else if (argumentString.contains(" to ")) {
			nameString = getEventNameTo(argumentString);
			argumentString = argumentString.split(nameString)[1].trim();

			DateGroup dateGroup = parseDateTimeString(nameString);

			if (dateGroup != null) {
				startDateTime = dateGroup.getDates().get(0);
				endDateTime = getDateTime(argumentString);

				String dateString = dateGroup.getText();
				nameString = nameString.split(dateString)[0].trim();
			} else {
				nameString = null;
				startDateTime = null;
				endDateTime = null;
			}

		} else {
			DateGroup dateGroup = parseDateTimeString(argumentString);

			if (dateGroup != null) {
				startDateTime = dateGroup.getDates().get(0);
				endDateTime = null;

				String dateString = dateGroup.getText();
				nameString = argumentString.split(dateString)[0].trim();
			} else {
				nameString = argumentString;
			}
		}

		if (startDateString != null) {
			SimpleDateFormat formatTime = new SimpleDateFormat(TIME_FORMAT);
			if (startDateTime != null) {
				startTimeString = formatTime.format(startDateTime);
				startDateTimeString = startDateString + DATE_DELIMETER + startTimeString;
			}

			if (endDateTime != null) {
				endTimeString = formatTime.format(endDateTime);
				endDateTimeString = startDateString + DATE_DELIMETER + endTimeString;
			}

		} else {
			if (startDateTime != null) {
				startDateTimeString = dateToString(startDateTime);
			}

			if (endDateTime != null) {
				endDateTimeString = dateToString(endDateTime);
			}
		}

		boolean validDate = true;

		if (startDateTime != null && endDateTime != null) {
			SimpleDateFormat df = new SimpleDateFormat(DATETIME_FORMAT);
			startDateTimeString = df.format(startDateTime);
			endDateTimeString = df.format(endDateTime);
			validDate = checkValidStartEnd(startDateTimeString, endDateTimeString);
		}

		if (validDate) {
			returnList.add(nameString);
			returnList.add(startDateTimeString);
			returnList.add(endDateTimeString);
		} else {
			return null;
		}
		return returnList;
	}

	private ArrayList<String> processAddTaskCommand(String argumentString) throws Exception {
		String nameString = null;
		Date dueDate = null;
		String dueDateString = null;

		ArrayList<String> returnList = new ArrayList<String>();

		if (argumentString.toLowerCase().contains("due")) {
			nameString = getTaskName(argumentString);
			dueDate = getTaskDueDate(argumentString);

		} else {
			DateGroup dateGroup = parseDateTimeString(argumentString);
			if (dateGroup != null) {
				dueDate = dateGroup.getDates().get(0);
				String dateString = dateGroup.getText();
				nameString = argumentString.split(dateString)[0].trim();
			} else {
				nameString = argumentString.trim();
				returnList.add(nameString);
				return returnList;
			}
		}

		if (dueDate != null) {
			dueDateString = dateToString(dueDate);
		}

		returnList.add(nameString);
		returnList.add(dueDateString);

		return returnList;
	}

	private Command processRemoveCommand(String argumentString) {
		int idx;
		Command command;
		boolean removeSeries = false;

		String all = getFirstWord(argumentString);

		if (all.equalsIgnoreCase("all")) {
			removeSeries = true;
			argumentString = removeFirstWord(argumentString);
		}

		idx = getId(argumentString);

		command = new RemoveCommand(calendar, indexStore, idx, removeSeries);
		return command;
	}

	private Command processUpdateCommand(String arguments) {
		int idx;
		boolean updateSeries = false;

		String all = getFirstWord(arguments);

		if (all.equalsIgnoreCase("all")) {
			updateSeries = true;
			arguments = removeFirstWord(arguments);
		}

		idx = getId(getFirstWord(arguments));

		ArrayList<String> fields = getFieldsList(arguments);
		ArrayList<String> newValues = getNewValuesList(arguments);

		if (idx != -1) {
			Command command = new UpdateCommand(calendar, indexStore, idx, fields, newValues, updateSeries);
			return command;
		} else {
			return null;
		}

	}

	private Command processDoneCommand(String argumentString) {
		int idx;
		Command command;

		idx = getId(argumentString);

		if (idx != -1) {
			command = new ToggleDoneCommand(calendar, indexStore, idx, true);
			return command;
		} else {
			return null;
		}
	}

	private Command processUndoneCommand(String argumentString) {
		int idx;
		Command command;

		idx = getId(argumentString);

		if (idx != -1) {
			command = new ToggleDoneCommand(calendar, indexStore, idx, false);
			return command;
		} else {
			return null;
		}
	}

	private Command processSearchCommand(String arguments) {
		Command command;
		command = new SearchCommand(calendar, arguments);
		return command;
	}

	private Command processDisplayCommand(String arguments) {
		Command command;
		command = new DisplayCommand(display, arguments);
		if (checkArguments(arguments)) {
			return command;
		} else {
			return null;
		}

	}

	private boolean checkArguments(String arguments) {
		switch (arguments.toLowerCase()) {
			case KEY_EVENTS :
			case KEY_TASKS :
			case KEY_UPCOMING_EVENTS :
			case KEY_UNDONE_TASKS :
			case KEY_MISSED_TASKS :
			case KEY_TODAY :
			case KEY_ALL :
				return true;
			default :
				return false;
		}
	}

	private Command processUndoCommand() {
		return new UndoCommand(calendar);
	}

	private Command processRedoCommand() {
		return new RedoCommand(calendar);
	}

	private Command processFilenameCommand(String arguments) {
		return new EditFileNameCommand(calendar, arguments);
	}

	private Command processClearCommand() {
		return new ClearCommand(calendar);
	}

	private Command processHelpCommand() {
		return new HelpCommand();
	}

	private Command processExitCommand() {
		return new ExitCommand();
	}

	private static Date getDateTime(String dateTimeString) throws Exception {
		try {
			if (dateTimeString.contains(" at ")) {
				String dateString = dateTimeString.split(" at ")[0].trim();
				String timeString = dateTimeString.split(" at ")[1].trim();
				
				dateString = formatDate(dateString);
				timeString = formatTime(timeString);
				
				Date parsedDate = null;
				
				if(dateString != null){
					if(timeString != null){
						String combinedDateTimeString = dateString + DATE_DELIMETER + timeString;
						SimpleDateFormat dateTimeFormat = new SimpleDateFormat(DATETIME_FORMAT);
						parsedDate = dateTimeFormat.parse(combinedDateTimeString);
					}else{
						CurrentTime currTime =  new CurrentTime();
						timeString = currTime.getHoursAndMin();
						
						String combinedDateTimeString = dateString + DATE_DELIMETER + timeString;
						SimpleDateFormat dateTimeFormat = new SimpleDateFormat(DATETIME_FORMAT);
						parsedDate = dateTimeFormat.parse(combinedDateTimeString);
					}
				}else{
					if(timeString != null){
						CurrentTime currTime =  new CurrentTime();
						dateString = currTime.getDate();
						
						String combinedDateTimeString = dateString + DATE_DELIMETER + timeString;
						SimpleDateFormat dateTimeFormat = new SimpleDateFormat(DATETIME_FORMAT);
						parsedDate = dateTimeFormat.parse(combinedDateTimeString);
					}else{
						return null;
					}
				}

				return parsedDate;
			} else {
				DateGroup dateGroup = parseDateTimeString(dateTimeString);
				return dateGroup.getDates().get(0);
			}
		} catch (Exception e) {
			return null;
		}
	}
	
	private String dateToString(Date date){
		SimpleDateFormat df = new SimpleDateFormat(DATETIME_FORMAT);
		return df.format(date);
	}

	public static String formatDate(String dateString) {
		if (validateDate(dateString)) {
			try {
				Date date = parseDateString(dateString);

				SimpleDateFormat df = new SimpleDateFormat(DATE_FORMAT_1);
				String dateStr = df.format(date);

				return dateStr;
			} catch (Exception e) {
				return null;
			}
		} else {
			DateGroup dateGroup = parseDateTimeString(dateString);
			Date date = dateGroup.getDates().get(0);

			if (date != null) {
				SimpleDateFormat df = new SimpleDateFormat(DATE_FORMAT_1);
				String dateStr = df.format(date);

				return dateStr;
			} else {
				return null;
			}
		}
	}

	public static String formatTime(String timeString) {
		if (validateTime(timeString)) {
			return timeString;
		} else {
			DateGroup dateGroup = parseDateTimeString(timeString);
			Date date = dateGroup.getDates().get(0);

			if (date != null) {
				SimpleDateFormat df = new SimpleDateFormat(TIME_FORMAT);
				String timeStr = df.format(date);

				return timeStr;
			} else {
				return null;
			}
		}
	}

	private static Date parseDateString(String dateString) throws Exception {
		SimpleDateFormat dateFormat;
		DateGroup dateGroup;
		Date date;

		// splits date according to
		if (dateString.contains("/")) {
			if (validateDate(dateString)) {
				dateFormat = new SimpleDateFormat(DATE_FORMAT_1);
				dateFormat.setLenient(false);
				date = dateFormat.parse(dateString);
			} else {
				throw new Exception();
			}
		} else if (dateString.contains("-")) {
			if (validateDate(dateString)) {
				dateFormat = new SimpleDateFormat(DATE_FORMAT_2);
				dateFormat.setLenient(false);
				date = dateFormat.parse(dateString);
			} else {
				throw new Exception();
			}
		} else if (dateString.contains(".")) {
			if (validateDate(dateString)) {
				dateFormat = new SimpleDateFormat(DATE_FORMAT_3);
				dateFormat.setLenient(false);
				date = dateFormat.parse(dateString);
			} else {
				throw new Exception();
			}
		} else {
			dateGroup = parseDateTimeString(dateString);
			if (dateGroup != null) {
				date = dateGroup.getDates().get(0);
			} else {
				date = null;
			}
		}
		return date;
	}

	private static boolean validateDate(String dateStr) {
		String regex = REGEX_DATE;
		if (dateStr.matches(regex)) {
			return true;
		} else {
			return false;
		}
	}

	private static boolean validateTime(String timeStr) {
		String regex = REGEX_TIME;
		if (timeStr.matches(regex)) {
			return true;
		} else {
			return false;
		}
	}



	/*****FOR ADD EVENTS FUNCTION*********/
	private String getEventNameFrom(String arguments) {
		String[] parameters = arguments.split(" from ");
		String returnString = parameters[0];

		for (int i = 1; i < parameters.length - 1; i++) {
			returnString += " from " + parameters[i];
		}
		return returnString;
	}

	private String getEventNameTo(String arguments) {
		String[] parameters = arguments.split(" to ");
		String returnString = parameters[0];

		for (int i = 1; i < parameters.length - 1; i++) {
			returnString += " to " + parameters[i];
		}
		return returnString;
	}

	private String getArgumentString(String arguments) {
		String[] parameters = arguments.split(" repeat ");
		String returnString = parameters[0];

		for (int i = 1; i < parameters.length - 1; i++) {
			returnString += " repeat " + parameters[i];
		}
		return returnString;
	}

	public static ArrayList<String> getRecurrArgs(String recurringArgs) throws Exception {
		String recurringType = null;
		Date recurringDate = null;
		String recurringDateStr = null;

		ArrayList<String> args = new ArrayList<String>();

		if (recurringArgs.contains(" till ")) {
			String[] split = recurringArgs.split(" till ");
			recurringType = split[0];
			recurringDate = getDateTime(split[1]);

			SimpleDateFormat df = new SimpleDateFormat(DATE_FORMAT_1);

			try {
				recurringDateStr = df.format(recurringDate);
			} catch (Exception e) {
				recurringDateStr = null;
			}
		} else {
			recurringType = recurringArgs;
		}

		if (recurringType.contains("every ")) {
			recurringType = processRecurringType(recurringType);
		}

		args.add(recurringType);
		args.add(recurringDateStr);

		return args;
	}

	private static String processRecurringType(String recurringType) {
		switch (recurringType.toLowerCase()) {
			case KEY_DAY :
				return KEY_DAILY;
			case KEY_WEEK :
				return KEY_WEEKLY;
			case KEY_MONTH :
				return KEY_MONTHLY;
			case KEY_YEAR :
				return KEY_ANNUALLY;
			default :
				return null;
		}
	}

	/*****FOR ADD TASK FUNCTION*********/
	private String getTaskName(String arguments) {
		String[] parameters1 = arguments.split("due");
		return parameters1[0].trim();
	}

	private Date getTaskDueDate(String arguments) throws Exception {
		String[] parameters1 = arguments.split("due");
		String dueDateString = parameters1[1].trim();
		Date dueDate = getDateTime(dueDateString);
		return dueDate;
	}

	private boolean checkValidStartEnd(String start, String end) {
		SimpleDateFormat df = new SimpleDateFormat(DATETIME_FORMAT);
		Date startDate = null;
		Date endDate = null;

		try {
			startDate = df.parse(start);
			endDate = df.parse(end);
		} catch (Exception e) {
			return false;
		}

		long startDateMilli = startDate.getTime();
		long endDateMilli = endDate.getTime();

		if (endDateMilli < startDateMilli) {
			return false;
		} else {
			return true;
		}
	}

	/*****FOR UPDATE FUNCTION*********/
	private ArrayList<String> getFieldsList(String arguments) {
		ArrayList<String> fields = new ArrayList<String>();
		arguments = removeFirstWord(arguments);
		if (arguments.contains(";")) {
			// more than one field to be updated
			String[] split = arguments.split("; ");
			for (int i = 0; i < split.length; i++) {
				String[] params = split[i].trim().split(":");
				fields.add(params[0].trim());
			}
		} else {
			String[] split = arguments.split(":");
			fields.add(split[0].trim());
		}
		return fields;
	}

	private ArrayList<String> getNewValuesList(String arguments) {
		ArrayList<String> newValues = new ArrayList<String>();
		arguments = removeFirstWord(arguments);
		if (arguments.contains(";")) {
			String[] split = arguments.split("; ");
			for (int i = 0; i < split.length; i++) {
				String[] params = split[i].split(":");
				if (params.length == 3) {
					String timeString = params[1] + ":" + params[2];
					newValues.add(timeString);
				} else {
					newValues.add(params[1]);
				}
			}
		} else {
			String[] split = arguments.split(":");

			if (split.length == 3) {
				String timeString = split[1] + ":" + split[2];
				newValues.add(timeString);
			} else {
				newValues.add(split[1]);
			}
		}
		return newValues;
	}

	/*****MISC HELPER FUNCTIONS*********/
	private int getId(String arguments) {
		try {
			int id = Integer.parseInt(arguments);
			return id;
		} catch (NumberFormatException e) {
			return -1;
		}

	}
	private String getFirstWord(String message) {
		String commandTypeString = message.trim().split("\\s+")[0];
		return commandTypeString;
	}

	private String removeFirstWord(String message) {
		String[] split = message.split("\\s+");
		String returnMessage = "";
		for (int i = 1; i < split.length; i++) {
			returnMessage += split[i] + " ";
		}
		returnMessage = returnMessage.trim();
		return returnMessage;
	}

	private static DateGroup parseDateTimeString(String dateTimeString) {
		Parser parser = new Parser();
		List<DateGroup> groups = parser.parse(dateTimeString);
		if (!groups.isEmpty()) {
			DateGroup dateGroup = groups.get(0);
			return dateGroup;
		} else {
			return null;
		}
	}
}
```
###### Tempo\Logic\Display.java
``` java
	public String formatSearchResults(ArrayList<CalendarObject> eventsBestMatch, ArrayList<CalendarObject> eventsAlternativeMatch, ArrayList<CalendarObject>tasksBestMatch, ArrayList<CalendarObject>tasksAlternativeMatch, ArrayList<CalendarObject>floatingTaskBestMatch, ArrayList<CalendarObject>floatingTasksAlternativeMatch){
		ArrayList<String> searchResults = new ArrayList<String>();
		
		boolean hasBestMatches = true;
		boolean hasAlternativeMatches = false;
		
		if(eventsBestMatch.isEmpty() && tasksBestMatch.isEmpty() && floatingTaskBestMatch.isEmpty()){
			hasBestMatches = false;
			searchResults.add(NO_BEST_MATCH);
		}else{
			searchResults.add(BEST_MATCH_STRING);
			searchResults.add(EMPTY_STRING);
			
			if(!eventsBestMatch.isEmpty()){
				searchResults.add(KEY_EVENTS);
				searchResults = addStrEventToArray(searchResults, eventsBestMatch);
			}
			
			if(!tasksBestMatch.isEmpty()){
				searchResults.add(EMPTY_STRING);
				searchResults.add(KEY_TASKS);
				searchResults = addStrTasksToArray(searchResults, tasksBestMatch);
			}
			
			if(!floatingTaskBestMatch.isEmpty()){
				searchResults.add(EMPTY_STRING);
				searchResults.add(KEY_FLOATING_TASKS);
				searchResults = addStrFTasksToArray(searchResults, floatingTaskBestMatch);
			}
		}
		
		searchResults.add(EMPTY_STRING);
		
		if(eventsAlternativeMatch.isEmpty() && tasksAlternativeMatch.isEmpty() && floatingTasksAlternativeMatch.isEmpty()){
			hasAlternativeMatches = false;
			searchResults.add(NO_ALTERNATIVE_MATCH);
		}else{
			searchResults.add(ALTERNATIVE_MATCH_STRING);
			searchResults.add(EMPTY_STRING);
			
			if(!eventsAlternativeMatch.isEmpty()){
				searchResults.add(KEY_EVENTS);
				searchResults = addStrEventToArray(searchResults, eventsAlternativeMatch);
			}
			
			if(!tasksAlternativeMatch.isEmpty()){
				searchResults.add(EMPTY_STRING);
				searchResults.add(KEY_TASKS);
				searchResults = addStrTasksToArray(searchResults, tasksAlternativeMatch);
			}
			
			if(!floatingTasksAlternativeMatch.isEmpty()){
				searchResults.add(EMPTY_STRING);
				searchResults.add(KEY_FLOATING_TASKS);
				searchResults = addStrFTasksToArray(searchResults, floatingTasksAlternativeMatch);
			}
		}
		
		if(!hasBestMatches && !hasAlternativeMatches){
			searchResults = new ArrayList<String>();
			searchResults.add(NO_MATCHES);
		}
		
		String returnString = strArrayToString(searchResults);
		
		return returnString;
	}
	
	private String strArrayToString(ArrayList<String> in){
		String s = "";
		
		for(String str : in){
			s += str+"\n";
		}
		
		return s;
	}
	
```
###### Tempo\Logic\RequestHandler.java
``` java
package Tempo.Logic;

import Tempo.Commands.Command;
import Tempo.Commands.Result;

public class RequestHandler {
	private static RequestHandler instance = new RequestHandler();

	private CommandParser parser;
	private Calendar calendar;

	private RequestHandler() {
		parser = CommandParser.getInstance();
		calendar = Calendar.getInstance();
	}

	public static RequestHandler getInstance() {
		return instance;
	}

	public Result processCommand(String commandString) {
		Command command = null;
		try {
			command = parser.parse(commandString);
			if (command != null) {
				return command.execute();
			} else {
			}
			return handleInvalidCommand(commandString);
		} catch (Exception e) {
			return handleInvalidCommand(commandString);
		}

	}

	private Result handleInvalidCommand(String commandString) {
		Result result = new Result(commandString, false, null);
		return result;
	}

	public String initialize(String filename) {
		calendar.createFile(filename);
		return filename + " is ready to use.";
	}

	public Calendar getCalendar() {
		return this.calendar;
	}
}
```
###### Tempo\Storage\CalendarExporter.java
``` java
package Tempo.Storage;

import java.io.*;
import java.util.ArrayList;

import Tempo.Data.CalendarObject;
import Tempo.Logic.Calendar;

public class CalendarExporter {
	private static CalendarExporter instance = new CalendarExporter();
	
	private String _fileName; 
	private static Calendar calendar;
	
	private ArrayList<CalendarObject> events;
	private ArrayList<CalendarObject> tasks;
	private ArrayList<CalendarObject> floatingTasks;
	
	private static final String HEADER_EVENTS = "--EVENTS--";
	private static final String HEADER_TASKS = "--TASKS--";
	private static final String HEADER_FLOATING_TASKS = "--FLOATING TASKS--";
	private BufferedWriter out;
	
	private CalendarExporter(){
		_fileName = "";
		events = new ArrayList<CalendarObject>();
		tasks = new ArrayList<CalendarObject>();
		floatingTasks = new ArrayList<CalendarObject>();
	}
	
	public static CalendarExporter getInstance(){
		return instance;
	}
	
	public boolean setFileName(String filename){
		_fileName = filename.trim();
		
		try{
			out = new BufferedWriter(new FileWriter(_fileName));
		}catch (Exception e){
			//UNABLE TO OPEN FILENAME
			return false;
		}
		return true;
	}
	
	public void export(){
		calendar = Calendar.getInstance();
		
		events = calendar.getEventsList();
		tasks = calendar.getTasksList();
		floatingTasks = calendar.getFloatingTasksList();
		
		try {
			out.write(HEADER_EVENTS + "\n");
			for(int i = 0; i < events.size(); i++){
				out.write(events.get(i).toString() + "\n");
			}
			out.write(HEADER_TASKS + "\n");
			for(int i = 0; i < tasks.size(); i++){
				out.write(tasks.get(i).toString() + "\n");
			}
			out.write(HEADER_FLOATING_TASKS + "\n");
			for(int i = 0; i < floatingTasks.size(); i++){
				out.write(floatingTasks.get(i).toString() + "\n");
			}
			out.flush();
			out.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
}
```
###### Tempo\Storage\CalendarImporter.java
``` java
package Tempo.Storage;

import java.io.*;
import java.util.*;

import Tempo.Data.CalendarObject;
import Tempo.Data.Event;
import Tempo.Data.FloatingTask;
import Tempo.Data.Task;

public class CalendarImporter {
	private static CalendarImporter instance = new CalendarImporter();
	
	private String _fileName; 
	
	private ArrayList<CalendarObject> events;
	private ArrayList<CalendarObject> tasks;
	private ArrayList<CalendarObject> floatingTasks;
	
	private BufferedReader in;
	
	private CalendarImporter(){
		events = new ArrayList<CalendarObject>();
		tasks = new ArrayList<CalendarObject>();
		floatingTasks = new ArrayList<CalendarObject>();
	}
	
	public static CalendarImporter getInstance(){
		return instance;
	}
	
	public boolean importFromFile(String fileName){
		_fileName = fileName;
		
		events = new ArrayList<CalendarObject>();
		tasks = new ArrayList<CalendarObject>();
		floatingTasks = new ArrayList<CalendarObject>();
		
		try {
			in  = new BufferedReader(new FileReader(_fileName));
		} catch (FileNotFoundException e) {
			System.out.println("Unable to read from file!");
			return false;
		}
		
		String currLine;
		try {
			while((currLine = in.readLine()) != null){				
				String[] split = currLine.trim().split("!!");
				
				if(split.length == 5){
					if(isBoolean(split[3])){
						int taskIndex = Integer.parseInt(split[0]);
						int taskSeriesIndex = Integer.parseInt(split[1]);
						Task newTask = new Task(taskIndex, taskSeriesIndex, split[2], split[3], split[4]);
						tasks.add(newTask);
					}else{
						int eventIndex = Integer.parseInt(split[0]);
						int eventSeriesIndex = Integer.parseInt(split[1]);
						Event newEvent  = new Event(eventIndex, eventSeriesIndex, split[2], split[3], split[4]);
						events.add(newEvent);
					}
				}else if (split.length == 4){
					int floatingTaskIndex = Integer.parseInt(split[0]);
					int floatingTaskSeriesIndex = Integer.parseInt(split[1]);
					FloatingTask newFloatingTask =  new FloatingTask(floatingTaskIndex, floatingTaskSeriesIndex, split[2], split[3]);
					floatingTasks.add(newFloatingTask);
				}
			}
			in.close();
		} catch (IOException e) {
			System.out.println("Error encountered when reading from file!");
			return false;
		}
		return true;
	}
	
	private boolean isBoolean(String booleanStr){
		if(booleanStr.equals("true") || booleanStr.equals("false")){
			return true;
		}else{
			return false;
		}
	}
	
	public ArrayList<CalendarObject> getEventsList(){		
		return events;
	}
	
	public ArrayList<CalendarObject> getTasksList(){
		return tasks;
	}
	
	public ArrayList<CalendarObject>getFloatingTasksList(){
		return floatingTasks;
	}
}
```
