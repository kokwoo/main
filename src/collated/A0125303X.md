# A0125303X
###### Tempo\Commands\DisplayCommand.java
``` java
package Tempo.Commands;

import Tempo.Logic.Display;

public class DisplayCommand implements Command {
	private Display display;
	private String displayType;

	// display arguments
	private final String ARG_EVENTS = "events";
	//private final String ARG_UPCOMING_EVENTS = "upcoming events";
	private final String ARG_TASKS = "tasks";
	private final String ARG_UNDONE_TASKS = "undone tasks";
	private final String ARG_MISSED_TASKS = "missed tasks";
	private final String ARG_TODAY = "today";
	private final String ARGS_ALL = "all";
	private final String ARG_EVENTS_TODAY = "events today";
	private final String ARG_EVENTS_UPCOMING = "upcoming events";
	private final String ARG_PAST_EVENTS = "past events";
	private final String ARG_TASKS_TODAY = "tasks today";
	private final String ARG_UPCOMING_TASKS = "upcoming tasks";
	private final String ARG_DONE_TASKS = "done tasks";
	private final String ARG_UNDONE_FTASKS = "undone floating tasks";
	private final String ARG_DONE_FTASKS = "done floating tasks";
	

//	private final String DISPLAY_ERROR = "Error: The command entered is invalid!";

	public DisplayCommand(Display display, String displayType) {
		this.display = display;
		this.displayType = displayType;
	}
	
	//The list of things that can be displayed
	/*getEventsToday
	getUpcomingEvents
	getPastEvents
	getTasksToday
	getUpcomingTasks
	getMissedTasks
	getUndoneTasks
	getDoneTasks
	getUndoneFloatingTasks
	getDoneFloatingTasks
	getAll
	getEvents
	getTasks
	getToday
	*/
	
	public Result execute() {
		display = Display.getInstance();
		
		switch (displayType) {
		case (ARG_EVENTS_TODAY):
			return display.getEventsToday();
		case (ARG_EVENTS_UPCOMING):
			return display.getUpcomingEvents();
		case (ARG_PAST_EVENTS):
			return display.getPastEvents();
		case (ARG_TASKS_TODAY):
			return display.getTasksToday();
		case (ARG_UPCOMING_TASKS):
			return display.getUpcomingTasks();
		case (ARG_MISSED_TASKS):
			return display.getMissedTasks();	
		case (ARG_UNDONE_TASKS):
			return display.getUndoneTasks();
		case (ARG_DONE_TASKS):
			return display.getDoneTasks();		
		case (ARG_UNDONE_FTASKS):
			return display.getUndoneFloatingTasks();
		case (ARG_DONE_FTASKS):
			return display.getDoneFloatingTasks();		
		case (ARG_EVENTS):
			return display.getEvents();
		case (ARG_TASKS):
			return display.getTasks();
		case (ARG_TODAY):
			return display.getToday();
		case (ARGS_ALL):
			return display.getAll();
		default:
			Result result = new Result("display", false, null);
			return result;
//			ArrayList<String> returnList = new ArrayList<String>();
//			returnList.add(DISPLAY_ERROR);
//			return returnList;

		}
	}

}
```
###### Tempo\Commands\SearchCommand.java
``` java
package Tempo.Commands;

import Tempo.Logic.Calendar;

public class SearchCommand implements Command {
	private Calendar cal;
	private String arguments;


	public SearchCommand(Calendar cal, String arguments) {
		this.cal = cal;
		this.arguments = arguments;
	}

	@Override
	public Result execute() {
			return cal.search(arguments);
	}
}
```
###### Tempo\Logic\CurrentTime.java
``` java
import java.text.DateFormat;
import java.text.SimpleDateFormat;
//import java.util.Date;
//import java.text.DateFormat;
//import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.GregorianCalendar;

public class CurrentTime {
	private static Calendar _date;
	private static Calendar cal = Calendar.getInstance();
	private static DateFormat date = new SimpleDateFormat("dd/MM/yyyy");
	private static DateFormat dateTime = new SimpleDateFormat("dd/MM/yyyy HH:mm");
	private static DateFormat time = new SimpleDateFormat("HH:mm");

	public CurrentTime() {
		Calendar date = new GregorianCalendar();
		_date = date;

	}

	public int getHour() {
		return _date.get(Calendar.HOUR);
	}

	public int getMinute() {
		return _date.get(Calendar.MINUTE);
	}

	public int getSecond() {
		return _date.get(Calendar.SECOND);
	}

	public int getYear() {
		return _date.get(Calendar.YEAR);
	}

	public String getMonth() {
		int month = _date.get(Calendar.MONTH)+1;
		if (month < 10) {
			return "0" + month;
		}
		return month + "";
	}

	public String getDay() {
		int day = _date.get(Calendar.DAY_OF_MONTH);
		if (day < 10) {
			return "0" + day;
		}
		return day + "";
	}
	
	public String getDate(){
		//System.out.println(df.format(cal.getTime()));
		
		return date.format(cal.getTime());
	}
	
	public String getDateAndTime() {
		return dateTime.format(cal.getTime());
	}
	
	public String getHoursAndMin() {
		return time.format(cal.getTime());
	}
	
//	public String getDate() {
//		CurrentDateAndTime date = new CurrentDateAndTime();
//		return date.getDay() + "/" + date.getMonth() + "/" + date.getYear();
//	}

}
```
###### Tempo\Logic\Display.java
``` java
public class Display {
	private Calendar cal = Calendar.getInstance();

	// Global variables
	private ArrayList<CalendarObject> events;
	private ArrayList<CalendarObject> eventsToday;
	private ArrayList<CalendarObject> upcomingEvents;
	private ArrayList<CalendarObject> pastEvents;
	private ArrayList<CalendarObject> tasks;
	private ArrayList<CalendarObject> tasksToday;
	private ArrayList<CalendarObject> upcomingTasks;
	private ArrayList<CalendarObject> missedTasks;
	private ArrayList<CalendarObject> floatingTasks;
	private ArrayList<CalendarObject> undoneTasks;
	private ArrayList<CalendarObject> undoneFloatingTasks;
	private ArrayList<CalendarObject> doneTasks;
	private ArrayList<CalendarObject> doneFloatingTasks;
	// private ArrayList<String> wordFoundLines;
	private CurrentTime date;

	// Messages
	private final String UPCOMING_EVENTS = "These are the list of upcoming events";
	private final String NO_UPCOMING_EVENTS = "You have no upcoming event";
	private final String TODAY_EVENTS = "These are your events for the day";
	private final String NO_TODAY_EVENTS = "You have no event today";
	private final String PAST_EVENTS = "These are the list of past events";
	private final String NO_PAST_EVENTS = "You have no past event";
	private final String TODAY_TASKS = "Tasks due today";
	private final String NO_TODAY_TASKS = "You have no task today";
	private final String UPCOMING_TASKS = "These are the list of upcoming tasks";
	private final String NO_UPCOMING_TASKS = "You have no upcoming task";
	private final String MISSED_TASKS = "These are the tasks you missed";
	private final String NO_MISSED_TASKS = "You have no missed task";
	private final String UNDONE_TASKS = "These are the list of undone tasks";
	private final String NO_UNDONE_TASKS = "You have no undone tasks";
	private final String DONE_TASKS = "These are all the tasks that are done";
	private final String NO_DONE_TASKS = "You have no done tasks";
	private final String UNDONE_FLOATING_TASKS = "These are the list of tasks without deadline";
	private final String NO_UNDONE_FLOATING_TASKS = "You have no task without deadline";
	private final String DONE_FLOATING_TASKS = "These are the list of tasks without deadline that are done";
	private final String NO_DONE_FLOATING_TASKS = "You have no task without deadline that are done";
	private final String EMPTY_STRING = "";
	
	private static final String NO_BEST_MATCH = "There are no best matches found!";
	private static final String BEST_MATCH_STRING = "These are the best matches found:";
	private static final String NO_ALTERNATIVE_MATCH = "There are no alternative matches found!";
	private static final String NO_MATCHES = "There are no matches found!";
	private static final String ALTERNATIVE_MATCH_STRING = "Other Results:";
	
	private static final String KEY_EVENTS = "Events";
	private static final String KEY_TASKS = "Tasks";
	private static final String KEY_FLOATING_TASKS = "Floating Tasks";

	// create an object of SingleObject
	private static Display instance = new Display();

	// make the constructor private so that this class cannot be
	// instantiated
	private Display() {
	}

	// Get the only object available
	public static Display getInstance() {
		return instance;
	}

	private void refresh() {
		cal = Calendar.getInstance();
		
		events = cal.getEventsList();
		tasks = cal.getTasksList();
		floatingTasks = cal.getFloatingTasksList();
		date = new CurrentTime();

		eventsToday = new ArrayList<CalendarObject>();
		upcomingEvents = new ArrayList<CalendarObject>();
		pastEvents = new ArrayList<CalendarObject>();

		tasksToday = new ArrayList<CalendarObject>();
		upcomingTasks = new ArrayList<CalendarObject>();
		missedTasks = new ArrayList<CalendarObject>();

		undoneTasks = new ArrayList<CalendarObject>();
		undoneFloatingTasks = new ArrayList<CalendarObject>();

		doneTasks = new ArrayList<CalendarObject>();
		doneFloatingTasks = new ArrayList<CalendarObject>();

		// System.out.println(events.size());
		// System.out.println(cal.getEventsList().get(0).getStartDate());

		splitsEvents();
		// splitting (floating) done and undone tasks
		splitFtasks();
		// splitting done and undone tasks
		splitTasks();
		// splitting the dated undone tasks
		splitDatedTask();
	}

	private void splitsEvents() {
		String currentDate = date.getDate();
		Date dateCurr = getDateInDateFormat(currentDate);
		// System.out.println(currentDate);
		for (int i = 0; i < events.size(); i++) {
			Date dateCompare = getDateInDateFormat(((Event) events.get(i)).getStartDate());
			if (dateCurr.compareTo(dateCompare) == 0) {
				eventsToday.add(events.get(i));
			} else if (dateCurr.compareTo(dateCompare) < 0) {
				upcomingEvents.add(events.get(i));
			} else if (dateCurr.compareTo(dateCompare) > 0) {
				pastEvents.add(events.get(i));
			}
		}
	}

	private Date getDateInDateFormat(String date) {
		SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
		Date formatDate = null;
		try {
			formatDate = sdf.parse(date);
		} catch (ParseException e) {
			System.out.println("Error fomatting date");
		}
		return formatDate;
	}

	private void splitFtasks() {
		for (int i = 0; i < floatingTasks.size(); i++) {
			if (!((FloatingTask) floatingTasks.get(i)).isDone()) {
				undoneFloatingTasks.add(floatingTasks.get(i));
			} else {
				doneFloatingTasks.add(floatingTasks.get(i));
			}
		}
	}

	private void splitTasks() {
		for (int i = 0; i < tasks.size(); i++) {
			if (!((FloatingTask) tasks.get(i)).isDone()) {
				undoneTasks.add(tasks.get(i));
			} else {
				doneTasks.add(tasks.get(i));
			}
		}
	}

	private void splitDatedTask() {
		String currentDate = date.getDate();
		Date dateCurr = getDateInDateFormat(currentDate);

		for (int i = 0; i < undoneTasks.size(); i++) {
			Date dateCompare = getDateInDateFormat(((Task) undoneTasks.get(i)).getDueDateSimplified());
			if (dateCurr.compareTo(dateCompare) == 0) {
				tasksToday.add(undoneTasks.get(i));
			} else if (dateCurr.compareTo(dateCompare) < 0) {
				upcomingTasks.add(undoneTasks.get(i));
			} else if (dateCurr.compareTo(dateCompare) > 0) {
				missedTasks.add(undoneTasks.get(i));
			}
		}
	}

	public Result getUpcomingEvents() {
		refresh();

		ArrayList<String> upcomingEventsStr = getUpcomingEventsString();
		String returnString = strArrayToString(upcomingEventsStr);

		HashMap<String, ArrayList<CalendarObject>> hm = new HashMap<String, ArrayList<CalendarObject>>();
		hm.put("upcomingEvents", upcomingEvents);
		Result upcomingEvents = new Result(returnString, true, true, hm);
		return upcomingEvents;
	}
	
	public ArrayList<String> getUpcomingEventsString() {
		refresh();

		ArrayList<String> upcomingEventsStr = new ArrayList<String>();
		if (upcomingEvents.isEmpty()) {
			upcomingEventsStr.add(NO_UPCOMING_EVENTS);
		} else {
			upcomingEventsStr.add(UPCOMING_EVENTS);
			upcomingEventsStr.add(EMPTY_STRING);
			upcomingEventsStr = addStrEventToArray(upcomingEventsStr, upcomingEvents);
		}
		
		return upcomingEventsStr;
	}

	public Result getEventsToday() {
		refresh();

		ArrayList<String> eventsTodayStr = getEventsTodayString();
		String returnString = strArrayToString(eventsTodayStr);

		HashMap<String, ArrayList<CalendarObject>> hm = new HashMap<String, ArrayList<CalendarObject>>();
		hm.put("Events", eventsToday);
		Result eventsToday = new Result(returnString, true, true, hm);

		return eventsToday;
	}
	
	public ArrayList<String> getEventsTodayString() {
		refresh();

		ArrayList<String> eventsTodayStr = new ArrayList<String>();
		if (eventsToday.isEmpty()) {
			eventsTodayStr.add(NO_TODAY_EVENTS);
		} else {
			eventsTodayStr.add(TODAY_EVENTS);
			eventsTodayStr.add(EMPTY_STRING);
			eventsTodayStr = addStrEventToArray(eventsTodayStr, eventsToday);
		}

		return eventsTodayStr;
	}

	public Result getPastEvents() {
		refresh();

		ArrayList<String> pastEventsStr = getPastEventsString();
		String returnString = strArrayToString(pastEventsStr);

		HashMap<String, ArrayList<CalendarObject>> hm = new HashMap<String, ArrayList<CalendarObject>>();
		hm.put("Events", pastEvents);
		Result pastEvents = new Result(returnString, true, true, hm);

		return pastEvents;
	}
	
	public ArrayList<String> getPastEventsString() {
		refresh();

		ArrayList<String> pastEventsStr = new ArrayList<String>();
		if (pastEvents.isEmpty()) {
			pastEventsStr.add(NO_PAST_EVENTS);
		} else {
			pastEventsStr.add(PAST_EVENTS);
			pastEventsStr.add(EMPTY_STRING);
			pastEventsStr = addStrEventToArray(pastEventsStr, pastEvents);
		}

		return pastEventsStr;
	}

	private ArrayList<String> addStrEventToArray(ArrayList<String> eventsStr, ArrayList<CalendarObject> events) {
		for (int i = 0; i < events.size(); i++) {
			Event currEvent = (Event)events.get(i);
			int num = i + 1;
			eventsStr.add(num + ") " + currEvent.getName() + " From: " + currEvent.getStartDateTime() + " To: "
					+ currEvent.getEndDateTime() + "\t[ID:" + currEvent.getIndex() + "] ");
		}
		return eventsStr;
	}
	
	/******TASKS ******/
	public Result getTasksToday() {
		refresh();
		ArrayList<String> tasksTodayStr = getTasksTodayString();
		String returnString = strArrayToString(tasksTodayStr);

		HashMap<String, ArrayList<CalendarObject>> hm = new HashMap<String, ArrayList<CalendarObject>>();
		hm.put("Tasks", tasksToday);
		Result tasksToday = new Result(returnString, true, true, hm);

		return tasksToday;
	}
	
	public ArrayList<String> getTasksTodayString() {
		refresh();
		ArrayList<String> tasksTodayStr = new ArrayList<String>();

		if (tasksToday.isEmpty()) {
			tasksTodayStr.add(NO_TODAY_TASKS);
		} else {
			tasksTodayStr.add(TODAY_TASKS);
			tasksTodayStr.add(EMPTY_STRING);
			tasksTodayStr = addStrTasksToArray(tasksTodayStr, tasksToday);
		}

		return tasksTodayStr;
	}

	public Result getUpcomingTasks() {
		refresh();
		ArrayList<String> upcomingTasksStr = getUpcomingTasksString();
		String returnString = strArrayToString(upcomingTasksStr);

		HashMap<String, ArrayList<CalendarObject>> hm = new HashMap<String, ArrayList<CalendarObject>>();
		hm.put("Tasks", upcomingTasks);
		Result upcomingTasks = new Result(returnString, true, true, hm);

		return upcomingTasks;
	}
	
	public ArrayList<String> getUpcomingTasksString() {
		refresh();
		ArrayList<String> upcomingTasksStr = new ArrayList<String>();

		if (upcomingTasks.isEmpty()) {
			upcomingTasksStr.add(NO_UPCOMING_TASKS);
		} else {
			upcomingTasksStr.add(UPCOMING_TASKS);
			upcomingTasksStr.add(EMPTY_STRING);
			upcomingTasksStr = addStrTasksToArray(upcomingTasksStr, upcomingTasks);
		}
		
		return upcomingTasksStr;
	}

	public Result getMissedTasks() {
		refresh();
		ArrayList<String> missedTasksStr = getMissedTasksString();
		String returnString = strArrayToString(missedTasksStr);


		HashMap<String, ArrayList<CalendarObject>> hm = new HashMap<String, ArrayList<CalendarObject>>();
		hm.put("Tasks", missedTasks);
		Result missedTasks = new Result(returnString, true, true, hm);

		return missedTasks;
	}
	
	public ArrayList<String> getMissedTasksString() {
		refresh();
		ArrayList<String> missedTasksStr = new ArrayList<String>();
		if (missedTasks.isEmpty()) {
			missedTasksStr.add(NO_MISSED_TASKS);
		} else {
			missedTasksStr.add(MISSED_TASKS);
			missedTasksStr.add(EMPTY_STRING);
			missedTasksStr = addStrTasksToArray(missedTasksStr, missedTasks);
		}

		return missedTasksStr;
	}

	public Result getUndoneTasks() {
		refresh();
		ArrayList<String> undoneTasksStr = getUndoneTasksString();
		String returnString = strArrayToString(undoneTasksStr);

		HashMap<String, ArrayList<CalendarObject>> hm = new HashMap<String, ArrayList<CalendarObject>>();
		hm.put("Tasks", undoneTasks);
		Result undoneTasks = new Result(returnString, true, true, hm);
		return undoneTasks;
	}
	
	public ArrayList<String> getUndoneTasksString(){
		refresh();
		ArrayList<String> undoneTasksStr = new ArrayList<String>();

		if (undoneTasks.isEmpty()) {
			undoneTasksStr.add(NO_UNDONE_TASKS);
		} else {
			undoneTasksStr.add(UNDONE_TASKS);
			undoneTasksStr.add(EMPTY_STRING);
			undoneTasksStr = addStrTasksToArray(undoneTasksStr, undoneTasks);
		}
		
		return undoneTasksStr;
	}

	public Result getDoneTasks() {
		refresh();
		ArrayList<String> doneTasksStr = getDoneTasksString();
		String returnString = strArrayToString(doneTasksStr);

		HashMap<String, ArrayList<CalendarObject>> hm = new HashMap<String, ArrayList<CalendarObject>>();
		hm.put("Tasks", doneTasks);
		Result doneTasks = new Result(returnString, true, true, hm);

		return doneTasks;
	}
	
	public ArrayList<String> getDoneTasksString() {
		refresh();
		ArrayList<String> doneTasksStr = new ArrayList<String>();
		if (doneTasks.isEmpty()) {
			doneTasksStr.add(NO_DONE_TASKS);
		} else {
			doneTasksStr.add(DONE_TASKS);
			doneTasksStr.add(EMPTY_STRING);
			doneTasksStr = addStrTasksToArray(doneTasksStr, doneTasks);
		}
		return doneTasksStr;
	}

	private ArrayList<String> addStrTasksToArray(ArrayList<String> tasksStr, ArrayList<CalendarObject> tasks) {
		for (int i = 0; i < tasks.size(); i++) {
			Task currTask = (Task)tasks.get(i);
			int num = i + 1;
			tasksStr.add(num + ") " + currTask.getName() + " Due: " + currTask.getDueDate() + "\t[ID:"
					+ currTask.getIndex() + "] ");
		}
		return tasksStr;
	}

	/*****FLOATING TASKS**********/
	public Result getUndoneFloatingTasks() {
		refresh();
		ArrayList<String> undoneFTasksStr = getUndoneFloatingTasksString();
		String returnString = strArrayToString(undoneFTasksStr);

		HashMap<String, ArrayList<CalendarObject>> hm = new HashMap<String, ArrayList<CalendarObject>>();
		hm.put("Tasks", undoneFloatingTasks);
		Result undoneFTasks = new Result(returnString, true, true, hm);

		return undoneFTasks;
	}
	
	public ArrayList<String> getUndoneFloatingTasksString() {
		refresh();
		ArrayList<String> undoneFTasksStr = new ArrayList<String>();

		if (undoneFloatingTasks.isEmpty()) {
			undoneFTasksStr.add(NO_UNDONE_FLOATING_TASKS);
		} else {
			undoneFTasksStr.add(UNDONE_FLOATING_TASKS);
			undoneFTasksStr.add(EMPTY_STRING);
			undoneFTasksStr = addStrFTasksToArray(undoneFTasksStr, undoneFloatingTasks);
		}
		return undoneFTasksStr;
	}

	public Result getDoneFloatingTasks() {
		refresh();
		ArrayList<String> doneFTasksStr =getDoneFloatingTasksString();
		String returnString = strArrayToString(doneFTasksStr);

		HashMap<String, ArrayList<CalendarObject>> hm = new HashMap<String, ArrayList<CalendarObject>>();
		hm.put("Tasks", doneFloatingTasks);
		Result doneFTasks = new Result(returnString, true, true, hm);

		return doneFTasks;
	}
	
	public ArrayList<String> getDoneFloatingTasksString() {
		refresh();
		ArrayList<String> doneFTasksStr = new ArrayList<String>();
		if (doneFloatingTasks.isEmpty()) {
			doneFTasksStr.add(NO_DONE_FLOATING_TASKS);
		} else {
			doneFTasksStr.add(DONE_FLOATING_TASKS);
			doneFTasksStr.add(EMPTY_STRING);
			doneFTasksStr = addStrFTasksToArray(doneFTasksStr, doneFloatingTasks);
		}
		return doneFTasksStr;
	}

	private ArrayList<String> addStrFTasksToArray(ArrayList<String> fTasksStr, ArrayList<CalendarObject> fTasks) {
		for (int i = 0; i < fTasks.size(); i++) {
			FloatingTask currFT = (FloatingTask)fTasks.get(i);
			int num = i + 1;
			fTasksStr.add(num + ") " + currFT.getName() + "\t[ID:" + currFT.getIndex() + "] ");
		}
		return fTasksStr;
	}

	public Result getEvents() {
		refresh();
		 ArrayList<String> eventsStr = new ArrayList<String>();
		 eventsStr.addAll(getEventsTodayString());
		 eventsStr.addAll(getUpcomingEventsString());
		 eventsStr.addAll(getPastEventsString());
		 
		 String returnString = strArrayToString(eventsStr);

		HashMap<String, ArrayList<CalendarObject>> hm = new HashMap<String, ArrayList<CalendarObject>>();
		hm.put("eventsToday", eventsToday);
		hm.put("upcomingEvents", upcomingEvents);
		hm.put("pastEvents", pastEvents);
		Result events = new Result(returnString, true, true, hm);

		return events;

	}
	
	public ArrayList<String> getEventsString() {
		refresh();
		
		 ArrayList<String> eventsStr = new ArrayList<String>();
		 eventsStr.addAll(getEventsTodayString());
		 eventsStr.add(EMPTY_STRING);
		 eventsStr.addAll(getUpcomingEventsString());
		 eventsStr.add(EMPTY_STRING);
		 eventsStr.addAll(getPastEventsString());
		 eventsStr.add(EMPTY_STRING);

		return eventsStr;

	}

	public Result getTasks() {
		refresh();
		
		 ArrayList<String> tasksStr = getTasksString();
		 
		 String returnString = strArrayToString(tasksStr);

		HashMap<String, ArrayList<CalendarObject>> hm = new HashMap<String, ArrayList<CalendarObject>>();
		hm.put("tasksToday", tasksToday);
		hm.put("upcomingTasks", upcomingTasks);
		hm.put("missedTasks", missedTasks);
		hm.put("doneTasks", doneTasks);
		Result tasks = new Result(returnString, true, true, hm);

		return tasks;
	}
	
	public ArrayList<String> getTasksString() {
		refresh();
		
		 ArrayList<String> tasksStr = new ArrayList<String>();
		 tasksStr.addAll(getUndoneFloatingTasksString());
		 tasksStr.add(EMPTY_STRING);
		 tasksStr.addAll(getDoneFloatingTasksString());
		 tasksStr.add(EMPTY_STRING);
		 tasksStr.addAll(getDoneTasksString());
		 tasksStr.add(EMPTY_STRING);
		 tasksStr.addAll(getTasksTodayString());
		 tasksStr.add(EMPTY_STRING);
		 tasksStr.addAll(getUpcomingTasksString());
		 tasksStr.add(EMPTY_STRING);
		 tasksStr.addAll(getMissedTasksString());
		 tasksStr.add(EMPTY_STRING);

		return tasksStr;
	}

	public Result getAll() {
		refresh();

		 ArrayList<String> all = new ArrayList<String>();
		 all.addAll(getEventsString());
		 all.addAll(getTasksString());
		
		 String returnString = strArrayToString(all);

		HashMap<String, ArrayList<CalendarObject>> hm = new HashMap<String, ArrayList<CalendarObject>>();
		hm.put("tasksToday", tasksToday);
		hm.put("upcomingTasks", upcomingTasks);
		hm.put("missedTasks", missedTasks);
		hm.put("doneTasks", doneTasks);
		hm.put("eventsToday", eventsToday);
		hm.put("upcomingEvents", upcomingEvents);
		hm.put("pastEvents", pastEvents);
		hm.put("undoneFloatingTasks", undoneFloatingTasks);
		hm.put("doneFloatingTasks", doneFloatingTasks);
		
		Result result = new Result(returnString, true, true, hm);

		return result;
	}

	public Result getToday() {
		ArrayList<String> todayString = getTodayString();
		String returnString = strArrayToString(todayString);
		
		HashMap<String, ArrayList<CalendarObject>> hm = new HashMap<String, ArrayList<CalendarObject>>();
		hm.put("tasksToday", tasksToday);
		hm.put("eventsToday", eventsToday);
		// hm.put("FloatingTasks", floatingTasks);
		Result today = new Result(returnString, true, true, hm);

		return today;
	}
	
	public ArrayList<String> getTodayString() {
		refresh();
		ArrayList<String> todayString = new ArrayList<String>();

		if (eventsToday.isEmpty()) {
			todayString.add(NO_TODAY_EVENTS);
		} else {
			todayString.add(TODAY_EVENTS);
			todayString = addStrEventToArray(todayString, eventsToday);
		}
		
		if (tasksToday.isEmpty()) {
			todayString.add(NO_TODAY_TASKS);
		} else {
			todayString.add(TODAY_TASKS);
			todayString = addStrEventToArray(todayString, tasksToday);
		}
		return todayString;
	}
	
```
###### Tempo\Logic\Display.java
``` java
	public static String getManual(){
		String manual = "";
		// INTRO
		manual += "Hello! This is the cheatsheet for tempo!\n";
		
		manual += "Manage TEMPO with the following KEYWORDS and PARAMETERS\n";
		manual += "The following cheatsheet shows you the function and the keywords you can use\n";
		manual += "<KEY>: keywords you can use for each function\n";
		manual += "<id>: id is the index of the event as supplied by “List all events”\n";
		manual += "<start date>/<end date>: day month year\n";
		manual += "<start time>/<end time>: 24 hours format\n";
		

		// how to add
		manual += "HOW TO ADD EVENT\n";
		manual += "================\n";
		manual += "<KEY>: add/create/new\n";
		manual += "<KEY> event <name> from <start date> at <start time> to <end date> at <end time>\n";
		

		// how to edit
		manual += "HOW TO EDIT EVENT\n";
		manual += "=================\n";
		manual += "<KEY>: edit/update/change\n";
		manual += "<KEY> event <id> <name> from <start date> at <start time> to <end date> at <end time>\n";
		manual += "For editing the event name only: <KEY> event <id> name: <name>\n";
		manual += "For editing the start date only: <KEY> event <id> start date: <start date>\n";
		manual += "For editing the start time only: <KEY> event <id> start time: <start time>\n";
		manual += "For editing of end date only: <KEY> event <id> end date: <end date>\n";
		manual += "For editing of end time only: <KEY> event <id> end time: <end time>\n";
		

		// how to add recurring events
		manual += "HOW TO ADD RECURRING EVENT\n";
		manual += "==========================\n";
		manual += "<KEY>: repeat\n";
		manual += "For daily recurring events: <KEY> event <id> daily until <end date>\n";
		manual += "For weekly recurring events: <KEY> event <id> weekly until <end date>\n";
		manual += "For monthly recurring events: <KEY> event <id> monthly until <end date>\n";
		manual += "For annually recurring events: <KEY> event <id> yearly until <end date>\n";
		

		// how to delete existing events
		manual += "HOW TO DELETE EXISTING EVENT\n";
		manual += "============================\n";
		manual += "<KEY>: delete/cancel/remove\n";
		manual += "<KEY> event <id>\n";
		

		// how to search events
		manual += "HOW TO SEARCH EXISTING EVENT\n";
		manual += "============================\n";
		manual += "<KEY>: search/find\n";
		manual += "By name: <KEY> event <keywords>\n";
		manual += "By id: <KEY> event <id>\n";
		

		// how to list upcoming events
		manual += "HOW TO LIST UPCOMING EVENT/S\n";
		manual += "============================\n";
		manual += "<KEY>: list/all/view/display\n";
		manual += "<KEY> upcoming events\n";
		

		// how to list all events
		manual += "HOW TO LIST ALL EVENT/S\n";
		manual += "=======================\n";
		manual += "<KEY>: list/all/view/display\n";
		manual += "<KEY> events\n";
		

		// how to add tasks
		manual += "HOW TO ADD TASK\n";
		manual += "===============\n";
		manual += "<KEY>: add/create/new\n";
		manual += "For tasks with no deadlines: <KEY> task <name>\n";
		manual += "For tasks with deadlines: <KEY> task <name> due <date>\n";
		

		// how to edit existing tasks
		manual += "HOW TO EDIT EXISTING TASK\n";
		manual += "=========================\n";
		manual += "<KEY>: edit/update/change\n";
		manual += "<KEY> task <id> <name> due <date>\n";
		manual += "For changing of name only: <KEY> task <id> name: <name>\n";
		manual += "For changing of due date only: <KEY> task <id> due: <date>\n";
		

		// how to delete existing tasks
		manual += "HOW TO DELETE EXISTING TASK\n";
		manual += "===========================\n";
		manual += "<KEY>: delete/cancel/remove\n";
		manual += "<KEY> task <id>\n";
		

		// how to search tasks
		manual += "HOW TO SEARCH EXISTING TASK\n";
		manual += "===========================\n";
		manual += "<KEY>: search/find\n";
		manual += "<KEY> task <keywords>\n";
		

		// how to list undone tasks
		manual += "HOW TO LIST UNDONE TASK/S\n";
		manual += "=========================\n";
		manual += "<KEY>: list/all/view/display\n";
		manual += "<KEY> undone tasks\n";
		

		// how to list missed tasks
		manual += "HOW TO LIST MISSED TASK/S\n";
		manual += "=========================\n";
		manual += "<KEY>: list/all/view/display\n";
		manual += "<KEY> missed tasks\n";
		

		// how to list all tasks
		manual += "HOW TO LIST ALL TASK/S\n";
		manual += "======================\n";
		manual += "<KEY>: list/all/view/display\n";
		manual += "<KEY> tasks\n";
		

		// how to mark task as done
		manual += "HOW TO MARK TASK AS DONE\n";
		manual += "========================\n";
		manual += "<KEY>: mark/flag\n";
		manual += "<KEY> task done <id>\n";
		

		// how to undo previous operation
		manual += "HOW TO UNDO PREVIOUS OPERATION\n";
		manual += "==============================\n";
		manual += "<KEY>: undo\n";
		manual += "<KEY>\n";
		

		// how to view today’s events and tasks due
		manual += "HOW TO VIEW EVENTS AND TASKS DUE TODAY \n";
		manual += "=======================================\n";
		manual += "<KEY>: view/display\n";
		manual += "<KEY> today\n";
		

		// how to view this week’s events and tasks due
		manual += "HOW TO VIEW EVENTS AND TASKS DUE THIS WEEK \n";
		manual += "===========================================\n";
		manual += "<KEY>: view/display\n";
		manual += "<KEY> week\n";
		
		return manual;
	}

}
```
###### Tempo\UI\TUI\Tempo.java
``` java
	private void printWelcomeMsg() {
		printGreetings();
		printDate();
		System.out.println(WELCOME_MESSAGE);
	}

	private void printGreetings() {
		DateFormat df = new SimpleDateFormat("HH");

		String timeString = df.format(getTime());

		int hour = Integer.parseInt(timeString);

		if (hour > 4 && hour <= 12) {
			System.out.print(GOOD_MORNING);
		} else if (hour > 12 && hour <= 16) {
			System.out.print(GOOD_AFTERNOON);
		} else {
			System.out.print(GOOD_EVENING);
		}
	}

	private void printDate() {
		DateFormat df = new SimpleDateFormat("EEEE, dd/MM/yyyy HH:mm");
		System.out.println("Today's date : " + df.format(getTime()));
	}

	private Date getTime() {
		return new Date();
	}

	private Result listenForInput() {
		String input = sc.nextLine();

		if (!input.equals("")) {
			return requestHandler.processCommand(input);

		} else {
			return listenForInput();
		}
	}
}
```
###### Tempo\UnitTesting\TestEvent.java
``` java
public class TestEvent extends TestCase {
	private static final String DELIMETER = "!!";
	private static final String DATE_DELIMETER = "/";

	@After
	public void tearDown() throws Exception {
	}

	@Test
	public final void testUpdateName() {
		Event tempEvent = new Event(0, 0, "Dinner with mum", "22/12/2015/19:00", "23/12/2015/19:00");
		tempEvent.update("name", "hello");
		assertEquals("hello", tempEvent.getName());
		tempEvent.update("name", "!!!!!!!!!!!!!!!!!!!!!!!!!!");
		assertEquals("!!!!!!!!!!!!!!!!!!!!!!!!!!", tempEvent.getName());
	}

	@Test
	public final void testUpdateStartDate() throws ParseException {
		Event tempEvent = new Event(0, 0, "Dinner with mum", "22/12/2015/19:00", "23/12/2015/19:00");
		tempEvent.update("start date", "12/12/2015");
		assertEquals("12/12/2015", tempEvent.getStartDate());
	}


	@Test
	public final void testUpdateStartTime() {
		Event tempEvent = new Event(0, 0, "Dinner with mum", "22/12/2015/19:00", "23/12/2015/19:00");
		tempEvent.update("start time", "23:59");
		assertEquals("23:59", tempEvent.getStartTime());

	}

	@Test
	public final void testUpdateEndDate() {
		Event tempEvent = new Event(0, 0, "Dinner with mum", "22/12/2015/19:00", "23/12/2015/19:00");
		tempEvent.update("end date", "30/12/2015");
		assertEquals("30/12/2015", tempEvent.getEndDate());

	}

	@Test
	public final void testUpdateEndTime() {
		Event tempEvent = new Event(0, 0, "Dinner with mum", "22/12/2015/19:00", "23/12/2015/19:00");
		tempEvent.update("end time", "12:00");
		assertEquals("12:00", tempEvent.getEndTime());

	}

	@Test
	public final void testGetIndex() {
		Event tempEvent = new Event(0, 0, "Dinner with mum", "22/12/2015/19:00", "23/12/2015/19:00");
		assertEquals(0, tempEvent.getIndex());

	}

	@Test
	public final void testGetSeries() {
		Event tempEvent = new Event(0, 0, "Dinner with mum", "22/12/2015/19:00", "23/12/2015/19:00");
		assertEquals(0, tempEvent.getSeriesIndex());

	}

	@Test
	public final void testName() {
		Event tempEvent = new Event(0, 0, "Dinner with mum", "22/12/2015/19:00", "23/12/2015/19:00");
		assertEquals("Dinner with mum", tempEvent.getName());
	}

	@Test
	public final void testGetStartDate() {
		Event tempEvent = new Event(0, 0, "Dinner with mum", "22/12/2015/19:00", "23/12/2015/19:00");
		assertEquals("22/12/2015", tempEvent.getStartDate());
	}

	@Test
	public final void testGetStartTime() {
		Event tempEvent = new Event(0, 0, "Dinner with mum", "22/12/2015/19:00", "23/12/2015/19:00");
		assertEquals("19:00", tempEvent.getStartTime());
	}

	@Test
	public final void testGetStartDateTime() {
		Event tempEvent = new Event(0, 0, "Dinner with mum", "07/11/2015/19:00", "23/12/2015/19:00");
		assertEquals("Saturday, 07/11/2015 19:00", tempEvent.getStartDateTime());
	}

	@Test
	public final void testGetStartDateTimeSimplified() {
		Event tempEvent = new Event(0, 0, "Dinner with mum", "07/11/2015/19:00", "23/12/2015/19:00");
		assertEquals("07/11/2015/19:00", tempEvent.getStartDateTimeSimplified());
	}
	
	@Test
	public final void testGetEndDate() {
		Event tempEvent = new Event(0, 0, "Dinner with mum", "21/12/2015/19:00", "22/12/2015/19:00");
		assertEquals("22/12/2015", tempEvent.getEndDate());
	}
	
	@Test
	public final void testGetEndTime() {
	

		Event tempEvent = new Event(0, 0, "Dinner with mum", "22/12/2015/19:00", "23/12/2015/19:00");
		Event tempEvent1 = new Event(0, 0, "Dinner with mum", "22/12/2015/19:00", "23/12/2015/23:59");
		ArrayList<String> actualArray = new ArrayList<String>();
		actualArray.add(tempEvent.getEndTime());
		actualArray.add(tempEvent1.getEndTime());
		ArrayList<String> expectedArray = new ArrayList<String>();
		expectedArray.add("19:00");
		expectedArray.add("23:59");
		assertEquals(expectedArray, actualArray);

	}

	@Test
	public final void testGetEndDateTime() {
		Event tempEvent = new Event(0, 0, "Dinner with mum", "02/11/2015/19:00", "07/11/2015/19:00");
		assertEquals("Saturday, 07/11/2015 19:00", tempEvent.getEndDateTime());
	}

	@Test
	public final void testGetEndDateTimeSimplified() {
		Event tempEvent = new Event(0, 0, "Dinner with mum", "02/11/2015/19:00", "07/11/2015/19:00");
		assertEquals("07/11/2015/19:00", tempEvent.getEndDateTimeSimplified());
	}	

	
	@Test
	public final void testClashesWith() {
		Event tempEvent = new Event(0, 0, "Dinner with mum", "07/11/2015/19:00", "07/11/2015/19:00");
		assertFalse(tempEvent.clashesWith(tempEvent));
		
		Event tempEvent1 = new Event(0, 0, "Dinner with mum", "08/11/2015/19:00", "07/11/2015/19:00");
		assertFalse(tempEvent1.clashesWith(tempEvent1));
		
		Event tempEvent2 = new Event(0, 0, "Dinner with mum", "07/11/2015/19:00", "09/11/2015/19:00");
		assertTrue(tempEvent2.clashesWith(tempEvent2));
				
	}
	
	@Test
	public final void testToString() {
		Event tempEvent = new Event(0, 0, "Dinner with mum", "07/11/2015/19:00", "23/12/2015/19:00");
		assertEquals("0!!0!!Dinner with mum!!07/11/2015/19:00!!23/12/2015/19:00", tempEvent.toString());
	}
	
	
	@Test
	public final void testCompareTo() {
		Event tempEvent = new Event(0, 0, "Dinner with mum", "07/11/2015/19:00", "23/12/2015/19:00");
		Event tempEvent1 = new Event(0, 0, "Dinner with mum", "11/11/2015/19:00", "23/12/2015/19:00");
		Event tempEvent2 = new Event(0, 0, "Dinner with mum", "06/11/2015/19:00", "23/12/2015/19:00");
		assertEquals(-1, tempEvent.compareTo(tempEvent1));
		assertEquals(0, tempEvent.compareTo(tempEvent));
		assertEquals(1, tempEvent.compareTo(tempEvent2));
	}
	

}
```
###### Tempo\UnitTesting\TestFloatingTask.java
``` java
public class TestFloatingTask {

	@After
	public void tearDown() throws Exception {
	}

	@Test
	public final void testGetName() {
		FloatingTask tempFT = new FloatingTask(0, 0, "Dinner", "done");
		assertEquals("Dinner", tempFT.getName());
	}
	
	@Test
	public final void testGetIndex() {
		FloatingTask tempFT = new FloatingTask(0, 0, "Dinner", "done");
		assertEquals(0, tempFT.getIndex());
	}
	
	@Test
	public final void testGetSeriesIndex() {
		FloatingTask tempFT = new FloatingTask(0, 0, "Dinner", "done");
		assertEquals(0, tempFT.getSeriesIndex());
	}
	
	@Test
	public final void testUpdateName() {
		FloatingTask tempFT = new FloatingTask(0, 0, "Dinner", "done");
		tempFT.update("name", "Lunch");
		assertEquals("Lunch", tempFT.getName());
	}
	
	@Test
	public final void testMarkDone() {
		FloatingTask tempFT = new FloatingTask(0, 0, "Dinner", "done");
		tempFT.markAsDone();
		assertTrue(tempFT.isDone());
	}
	
	@Test
	public final void testMarkUndone() {
		FloatingTask tempFT = new FloatingTask(0, 0, "Dinner", "done");
		tempFT.markAsUndone();
		assertFalse(tempFT.isDone());
	}
	
	@Test
	public final void testToString() {
		FloatingTask tempFT = new FloatingTask(0, 0, "Dinner", "done");
		assertEquals("0!!0!!Dinner!!false", tempFT.toString());
	}

}
```
###### Tempo\UnitTesting\TestLogic.java
``` java

	// CMD
	private static final String CMD_EVENT = "events";
	private static final String CMD_TASK = "tasks";
	private static final String CMD_FLOATING_TASK = "floating tasks";

	private static final String CMD_ADD_EVENT = "add event %1$s";
	private static final String CMD_ADD_TASK = "add task %1$s";
	private static final String CMD_ADD_FLOATING = "add floating task %1$s";
	private static final String CMD_ADD_RECURR_EVENT = "add recurring event %1$s";
	private static final String CMD_ADD_RECURR_TASK = "add recurring task %1$s";

	private static final String CMD_REMOVE_EVENT = "remove event %1$s";
	private static final String CMD_REMOVE_TASK = "remove task %1$s";
	private static final String CMD_REMOVE_FLOATING = "remove floating task %1$s";

	private static final String CMD_REMOVE = "remove ";

	private static final String CMD_UPDATE_EVENT = "update event %1$s";
	private static final String CMD_UPDATE_TASK = "update task %1$s";
	private static final String CMD_UPDATE_FLOATING = "update floating task %1$s";

	// MSG
	private static final String TEST_ADD_EVENT = "add event Dinner with mum from 22/11/2015 at 19:00 to 24/11/2015 at 19:00";
	private static final String TEST_ADD_EVENT_ERROR = "add event Dinner with mum from 45/12/2015 at 19:00 to 24/12/2015 at 19:00";
	private static final String TEST_ADD_EVENT_ERROR_1 = "add event Dinner with mum from 22/22/2015 at 19:00 to 24/12/2015 at 19:00";
	private static final String TEST_ADD_EVENT_ERROR_2 = "add event Dinner with mum from 22/12/9999 at 19:00 to 24/12/2015 at 19:00";
	private static final String TEST_ADD_EVENT_ERROR_3 = "add event Dinner with mum from 22/12/2015 at 55:55 to 24/12/2015 at 19:00";
	private static final String TEST_ADD_EVENT_ERROR_4 = "add event Dinner with mum from 30/12/2015 at 19:00 to 24/12/2015 at 19:00";

	private static final String TEST_ADD_TASK = "add task Lunch with mum due 12/12/2015";
	private static final String TEST_ADD_TASK_ERROR = "add task Dinner with mum due 45/12/2015";
	private static final String TEST_ADD_TASK_ERROR_1 = "add task Dinner with mum due 45/12/2015";
	private static final String TEST_ADD_TASK_ERROR_2 = "add task Dinner with mum due 45/12/2015";

	private static final String TEST_ADD_FTASK = "add task Dinner with mum";

	@After
	public void tearDown() throws Exception {
	}

	@Test
	public final void testClearFile() {
		String fileName = "testfile.txt";
		RequestHandler tempRH = initTempRH();

		String returnString = String.format("%1$s has been cleared.", fileName);
		Result tempResult = new Result(returnString, true, true, null);

		assertBooleanAndStrCmd(tempRH, tempResult, "clear file");
		assertEquals(tempResult.getResults(), tempRH.processCommand("clear file").getResults());
	}

	@Test
	public final void testAddEvent() {
		int pass = 0;
		// To test
		RequestHandler tempRH = initTempRH();

		// all test cases should pass
		// equivalence testing
		// invalid date
		tryCatchAdd(pass, tempRH, TEST_ADD_EVENT_ERROR);
		tryCatchAdd(pass, tempRH, TEST_ADD_EVENT_ERROR_1);
		tryCatchAdd(pass, tempRH, TEST_ADD_EVENT_ERROR_2);
		// invalid time
		tryCatchAdd(pass, tempRH, TEST_ADD_EVENT_ERROR_3);
		// end date before start date
		tryCatchAdd(pass, tempRH, TEST_ADD_EVENT_ERROR_4);

		// checker
		ArrayList<CalendarObject> checkArray = new ArrayList<CalendarObject>();
		Event checkEvent = new Event(0, 0, "Dinner with mum", "22/11/2015/19:00", "24/11/2015/19:00");
		checkArray.add(checkEvent);
		String cmd = String.format(CMD_ADD_EVENT, "Dinner with mum");
		Result tempResult = new Result(cmd, true, putHashMap(CMD_EVENT, checkArray));

		// Compare results object
		assertBooleanAndStrCmd(tempRH, tempResult, TEST_ADD_EVENT);
		clearFile(tempRH);

		ArrayList<CalendarObject> expectedArray = getEventArray(tempResult);
		ArrayList<CalendarObject> actualArray = tempRH.processCommand(TEST_ADD_EVENT).getResults().get(CMD_EVENT);
		assertEquals(expectedArray.toString(), actualArray.toString());
		clearFile(tempRH);

	}

	@Test
	public final void testAddTask() {
		int pass = 0;
		// To test
		RequestHandler tempRH = initTempRH();

		// equivalence testing
		// invalid date
		// all values should pass
		tryCatchAdd(pass, tempRH, TEST_ADD_TASK_ERROR);
		tryCatchAdd(pass, tempRH, TEST_ADD_TASK_ERROR_1);
		tryCatchAdd(pass, tempRH, TEST_ADD_TASK_ERROR_2);

		// checker
		ArrayList<CalendarObject> checkArray = new ArrayList<CalendarObject>();
		Task checkTask = new Task(0, 0, "Lunch with mum", "12/12/2015");
		checkArray.add(checkTask);
		String cmd = String.format(CMD_ADD_TASK, "Lunch with mum");
		Result tempResult = new Result(cmd, true, putHashMap(CMD_TASK, checkArray));

		// Compare results object
		assertBooleanAndStrCmd(tempRH, tempResult, TEST_ADD_TASK);
		clearFile(tempRH);

		ArrayList<CalendarObject> expectedArray = getTaskArray(tempResult);
		ArrayList<CalendarObject> actualArray = tempRH.processCommand(TEST_ADD_TASK).getResults().get(CMD_TASK);
		assertEquals(expectedArray.toString(), actualArray.toString());
		clearFile(tempRH);

	}

	@Test
	public final void testAddFTask() {
		// To test
		RequestHandler tempRH = initTempRH();

		// checker
		ArrayList<CalendarObject> checkArray = new ArrayList<CalendarObject>();
		FloatingTask checkTask = new FloatingTask(0, 0, "Dinner with mum");
		checkArray.add(checkTask);
		String cmd = String.format(CMD_ADD_FLOATING, "Dinner with mum");
		Result tempResult = new Result(cmd, true, putHashMap(CMD_FLOATING_TASK, checkArray));

		// Compare results object
		assertBooleanAndStrCmd(tempRH, tempResult, TEST_ADD_FTASK);
		clearFile(tempRH);

		ArrayList<CalendarObject> expectedArray = tempResult.getResults().get(CMD_FLOATING_TASK);
		ArrayList<CalendarObject> actualArray = tempRH.processCommand(TEST_ADD_FTASK).getResults()
				.get(CMD_FLOATING_TASK);
		assertEquals(expectedArray.toString(), actualArray.toString());
		clearFile(tempRH);

	}

	@Test
	public final void testRemoveEvent() {

		// to tesy
		RequestHandler tempRH = initTempRH();
		clearFile(tempRH);
		tempRH.processCommand(TEST_ADD_EVENT);
		tempRH.processCommand(TEST_ADD_EVENT);
		tempRH.processCommand(TEST_ADD_EVENT);

		// checker
		String cmd = String.format(CMD_REMOVE_EVENT, "Dinner with mum");
		Result tempResult = new Result(cmd, true, putHashMap(CMD_EVENT, null));

		// Compare results object
		assertEquals(tempResult.getCmdPerformed(), tempRH.processCommand(CMD_REMOVE + 0).getCmdPerformed());
		assertEquals(tempResult.isSuccess(), tempRH.processCommand(CMD_REMOVE + 1).isSuccess());
		assertEquals(tempResult.isDisplayResult(), tempRH.processCommand(CMD_REMOVE + 2).isDisplayResult());
		// equivalence testing
		try {
			assertEquals(tempResult.isDisplayResult(), tempRH.processCommand(CMD_REMOVE + 3).isDisplayResult());
			assertEquals(tempResult.isDisplayResult(), tempRH.processCommand(CMD_REMOVE + -1).isDisplayResult());
		} catch (NullPointerException ex) {

		}
		clearFile(tempRH);
	}

	@Test
	public final void testRemoveTask() {
		// To test
		RequestHandler tempRH = initTempRH();
		clearFile(tempRH);
		tempRH.processCommand(TEST_ADD_TASK);
		tempRH.processCommand(TEST_ADD_TASK);
		tempRH.processCommand(TEST_ADD_TASK);

		// checker
		ArrayList<CalendarObject> checkArray = new ArrayList<CalendarObject>();
		String cmd = String.format(CMD_REMOVE_TASK, "Lunch with mum");
		Result tempResult = new Result(cmd, true, putHashMap(CMD_TASK, checkArray));

		// Compare results object
		assertEquals(tempResult.getCmdPerformed(), tempRH.processCommand(CMD_REMOVE + 0).getCmdPerformed());
		assertEquals(tempResult.isSuccess(), tempRH.processCommand(CMD_REMOVE + 1).isSuccess());
		assertEquals(tempResult.isDisplayResult(), tempRH.processCommand(CMD_REMOVE + 2).isDisplayResult());

		// equivalence testing
		try {
			assertEquals(tempResult.isDisplayResult(), tempRH.processCommand(CMD_REMOVE + 3).isDisplayResult());
			assertEquals(tempResult.isDisplayResult(), tempRH.processCommand(CMD_REMOVE + -1).isDisplayResult());
		} catch (NullPointerException ex) {

		}
		clearFile(tempRH);

	}

	@Test
	public final void testRemoveFTask() {
		// To test
		RequestHandler tempRH = initTempRH();
		clearFile(tempRH);
		tempRH.processCommand(TEST_ADD_FTASK);
		tempRH.processCommand(TEST_ADD_FTASK);
		tempRH.processCommand(TEST_ADD_FTASK);

		// checker
		ArrayList<CalendarObject> checkArray = new ArrayList<CalendarObject>();
		String cmd = String.format(CMD_REMOVE_FLOATING, "Dinner with mum");
		Result tempResult = new Result(cmd, true, putHashMap(CMD_FLOATING_TASK, checkArray));

		// Compare results object
		assertEquals(tempResult.getCmdPerformed(), tempRH.processCommand(CMD_REMOVE + 0).getCmdPerformed());
		assertEquals(tempResult.isSuccess(), tempRH.processCommand(CMD_REMOVE + 1).isSuccess());
		assertEquals(tempResult.isDisplayResult(), tempRH.processCommand(CMD_REMOVE + 2).isDisplayResult());

		// equivalence testing
		try {
			assertEquals(tempResult.isDisplayResult(), tempRH.processCommand(CMD_REMOVE + 3).isDisplayResult());
			assertEquals(tempResult.isDisplayResult(), tempRH.processCommand(CMD_REMOVE + -1).isDisplayResult());
		} catch (NullPointerException ex) {

		}
		clearFile(tempRH);

	}

	@Test
	public final void testUpdateEventEndTime() {
		// To test - initialize test.txt
		String event = "add event Dinner with mum from 22/11/2015 at 19:00 to 24/11/2015 at 19:00";
		RequestHandler tempRH = initTempRH();
		clearFile(tempRH);

		// checker
		ArrayList<CalendarObject> checkArray = new ArrayList<CalendarObject>();
		Event checkNewName = new Event(0, 0, "Dinner with mum", "22/11/2015/19:00", "24/11/2015/23:00");
		checkArray.add(checkNewName);

		String cmdName = String.format(CMD_UPDATE_EVENT, "Dinner with mum");
		Result tempResult = new Result(cmdName, true, putHashMap(CMD_EVENT, checkArray));

		tempRH.processCommand(event);
		ArrayList<CalendarObject> expectedArray = getEventArray(tempResult);
		ArrayList<CalendarObject> actualArray = tempRH.processCommand("update 0 end time:23:00").getResults()
				.get(CMD_EVENT);
		assertEquals(expectedArray.toString(), actualArray.toString());
		clearFile(tempRH);
	}

	@Test
	public final void testUpdateEventEndDate() {
		// To test - initialize test.txt
		String event = "add event Dinner with mum from 22/11/2015 at 19:00 to 24/11/2015 at 19:00";
		RequestHandler tempRH = initTempRH();
		clearFile(tempRH);

		// checker
		ArrayList<CalendarObject> checkArray = new ArrayList<CalendarObject>();
		Event checkNewName = new Event(0, 0, "Dinner with mum", "22/11/2015/19:00", "25/11/2015/19:00");
		checkArray.add(checkNewName);

		String cmdName = String.format(CMD_UPDATE_EVENT, "Dinner with mum");
		Result tempResult = new Result(cmdName, true, putHashMap(CMD_EVENT, checkArray));

		tempRH.processCommand(event);
		ArrayList<CalendarObject> expectedArray = getEventArray(tempResult);
		ArrayList<CalendarObject> actualArray = tempRH.processCommand("update 0 end date:25/11/2015").getResults()
				.get(CMD_EVENT);
		assertEquals(expectedArray.toString(), actualArray.toString());
		clearFile(tempRH);
	}

	@Test
	public final void testUpdateEventStartTime() {
		// To test - initialize test.txt
		String event = "add event Dinner with mum from 22/11/2015 at 19:00 to 24/11/2015 at 19:00";
		RequestHandler tempRH = initTempRH();
		clearFile(tempRH);

		// checker
		ArrayList<CalendarObject> checkArray = new ArrayList<CalendarObject>();
		Event checkNewName = new Event(0, 0, "Dinner with mum", "22/11/2015/23:00", "24/11/2015/19:00");
		checkArray.add(checkNewName);

		String cmdName = String.format(CMD_UPDATE_EVENT, "Dinner with mum");
		Result tempResult = new Result(cmdName, true, putHashMap(CMD_EVENT, checkArray));

		tempRH.processCommand(event);
		ArrayList<CalendarObject> expectedArray = getEventArray(tempResult);
		ArrayList<CalendarObject> actualArray = tempRH.processCommand("update 0 start time:23:00").getResults()
				.get(CMD_EVENT);
		assertEquals(expectedArray.toString(), actualArray.toString());
		clearFile(tempRH);
	}

	@Test
	public final void testUpdateEventStartDate() {
		// To test - initialize test.txt
		String event = "add event Dinner with mum from 22/11/2015 at 19:00 to 24/11/2015 at 19:00";
		RequestHandler tempRH = initTempRH();
		clearFile(tempRH);

		// checker for updating start date
		ArrayList<CalendarObject> checkArray = new ArrayList<CalendarObject>();
		Event checkNewName = new Event(0, 0, "Dinner with mum", "21/11/2015/19:00", "24/11/2015/19:00");
		checkArray.add(checkNewName);

		String cmdName = String.format(CMD_UPDATE_EVENT, "Dinner with mum");
		Result tempResult = new Result(cmdName, true, putHashMap(CMD_EVENT, checkArray));

		tempRH.processCommand(event);
		ArrayList<CalendarObject> expectedArray = getEventArray(tempResult);
		ArrayList<CalendarObject> actualArray = tempRH.processCommand("update 0 start date:21/11/2015").getResults()
				.get(CMD_EVENT);
		assertEquals(expectedArray.toString(), actualArray.toString());
		clearFile(tempRH);
	}

	@Test
	public final void testUpdateEventName() {
		// To test - initialize test.txt
		String event = "add event Dinner with mum from 22/11/2015 at 19:00 to 24/11/2015 at 19:00";
		RequestHandler tempRH = initTempRH();
		clearFile(tempRH);

		// checker for both updating name and due date
		ArrayList<CalendarObject> checkArray = new ArrayList<CalendarObject>();
		Event checkNewName = new Event(0, 0, "changed", "22/11/2015/19:00", "24/11/2015/19:00");
		checkArray.add(checkNewName);

		String cmdName = String.format(CMD_UPDATE_EVENT, "changed");
		Result tempResult = new Result(cmdName, true, putHashMap(CMD_EVENT, checkArray));

		tempRH.processCommand(event);
		ArrayList<CalendarObject> expectedArray = getEventArray(tempResult);
		ArrayList<CalendarObject> actualArray = tempRH.processCommand("update 0 name:changed").getResults()
				.get(CMD_EVENT);
		assertEquals(expectedArray.toString(), actualArray.toString());
		clearFile(tempRH);
	}

	@Test
	public final void testUpdateTaskName() {
		// To test - initialize test.txt
		String task = "add task Gymming due 12/12/2015";
		RequestHandler tempRH = initTempRH();
		clearFile(tempRH);

		// checker for updating name
		ArrayList<CalendarObject> checkArray = new ArrayList<CalendarObject>();
		Task checkNewName = new Task(0, 0, "okok", "12/12/2015");
		checkArray.add(checkNewName);

		String cmdName = String.format(CMD_UPDATE_TASK, "okok");
		Result tempResult = new Result(cmdName, true, putHashMap(CMD_TASK, checkArray));

		tempRH.processCommand(task);
		ArrayList<CalendarObject> expectedArray = getTaskArray(tempResult);
		ArrayList<CalendarObject> actualArray = tempRH.processCommand("update 0 name:okok").getResults().get(CMD_TASK);
		assertEquals(expectedArray.toString(), actualArray.toString());
		clearFile(tempRH);
	}

	@Test
	public final void testUpdateTaskDue() {
		// To test - initialize test.txt
		String task = "add task Gymming due 12/12/2015";
		RequestHandler tempRH = initTempRH();
		clearFile(tempRH);

		// checker for due date
		ArrayList<CalendarObject> checkArray = new ArrayList<CalendarObject>();
		Task checkNewDueDate = new Task(0, 0, "Gymming", "23/11/2015");
		checkArray.add(checkNewDueDate);

		String cmdDueDate = String.format(CMD_UPDATE_TASK, "Gymming");
		Result tempResult1 = new Result(cmdDueDate, true, putHashMap(CMD_TASK, checkArray));

		// Compare results object
		tempRH.processCommand(task);
		ArrayList<CalendarObject> expectedArray = getTaskArray(tempResult1);
		ArrayList<CalendarObject> actualArray = tempRH.processCommand("update 0 due:23/11/2015").getResults()
				.get(CMD_TASK);
		assertEquals(expectedArray.toString(), actualArray.toString());
		clearFile(tempRH);

	}

	@Test
	public final void testUpdateFTaskName() {
		// To test - initialize test.txt
		String task = "add task Gymming";
		RequestHandler tempRH = initTempRH();
		clearFile(tempRH);

		// checker for due date
		ArrayList<CalendarObject> checkArray = new ArrayList<CalendarObject>();
		FloatingTask checkNewDueDate = new FloatingTask(0, 0, "changed");
		checkArray.add(checkNewDueDate);

		String cmdDueDate = String.format(CMD_UPDATE_FLOATING, "changed");
		Result tempResult1 = new Result(cmdDueDate, true, putHashMap(CMD_FLOATING_TASK, checkArray));

		// Compare results object
		tempRH.processCommand(task);
		ArrayList<CalendarObject> expectedArray = tempResult1.getResults().get("floating tasks");
		ArrayList<CalendarObject> actualArray = tempRH.processCommand("update 0 name:changed").getResults()
				.get(CMD_FLOATING_TASK);
		assertEquals(expectedArray.toString(), actualArray.toString());
		clearFile(tempRH);

	}

	@Test
	public final void testDisplayAll() {
		RequestHandler tempRH = initTempRH();

		assertTrue(tempRH.processCommand("display all").isDisplayResult());
		assertTrue(tempRH.processCommand("display all").isSuccess());
		clearFile(tempRH);
		// checker
		ArrayList<String> checkerArray = new ArrayList<String>();
		checkerArray.add("You have no event today");
		checkerArray.add("");
		checkerArray.add("You have no upcoming event");
		checkerArray.add("");
		checkerArray.add("You have no past event");
		checkerArray.add("");
		checkerArray.add("You have no task without deadline");
		checkerArray.add("");
		checkerArray.add("You have no task without deadline that are done");
		checkerArray.add("");
		checkerArray.add("You have no done tasks");
		checkerArray.add("");
		checkerArray.add("You have no task today");
		checkerArray.add("");
		checkerArray.add("You have no upcoming task");
		checkerArray.add("");
		checkerArray.add("You have no missed task");
		checkerArray.add("");

		String checkerString = strArrayToString(checkerArray);

		// compare results
		assertEquals(checkerString, tempRH.processCommand("display all").getCmdPerformed());
		clearFile(tempRH);
	}

	@Test
	// equivalence testing
	public final void testDisplayAll1() {
		RequestHandler tempRH = initTempRH();
		// upcoming event
		tempRH.processCommand("add event date with gf from 23/12/2015 at 17:00 to 26/12/2015 at 19:00");
		// past event
		tempRH.processCommand("add event gymming from 06/11/2015 at 19:00 to 07/11/2015 at 19:00");
		// event today
		tempRH.processCommand("add event Dinner with mum from 08/11/2015 at 21:00 to 09/11/2015 at 21:00");
		// past task
		tempRH.processCommand("add task Dinner with bf due 06/11/2015");
		// today task
		tempRH.processCommand("add task Dinner with gf due 08/11/2015");
		// upcoming task
		tempRH.processCommand("add task Dinner with mum due 12/12/2015");
		// task done
		tempRH.processCommand("add task eat due 23/12/2015");
		tempRH.processCommand("done 6");
		// floating task
		tempRH.processCommand("add task Hello");
		// floating task done
		tempRH.processCommand("add task Hello2");
		tempRH.processCommand("done 8");

		assertTrue(tempRH.processCommand("display all").isDisplayResult());
		assertTrue(tempRH.processCommand("display all").isSuccess());

		// checker
		ArrayList<String> checkerArray = new ArrayList<String>();
		checkerArray.add("You have no event today");
		checkerArray.add("");
		checkerArray.add("These are the list of upcoming events");
		checkerArray.add("");
		checkerArray.add("1) date with gf From: Wednesday, 23/12/2015 17:00 To: Saturday, 26/12/2015 19:00	[ID:0] ");
		checkerArray.add("");
		checkerArray.add("These are the list of past events");
		checkerArray.add("");
		checkerArray.add("1) gymming From: Friday, 06/11/2015 19:00 To: Saturday, 07/11/2015 19:00	[ID:1] ");
		checkerArray.add("2) Dinner with mum From: Sunday, 08/11/2015 21:00 To: Monday, 09/11/2015 21:00	[ID:2] ");
		checkerArray.add("");
		checkerArray.add("These are the list of tasks without deadline");
		checkerArray.add("");
		checkerArray.add("1) Hello	[ID:7] ");
		checkerArray.add("");
		checkerArray.add("These are the list of tasks without deadline that are done");
		checkerArray.add("");
		checkerArray.add("1) Hello2	[ID:8] ");
		checkerArray.add("");
		checkerArray.add("These are all the tasks that are done");
		checkerArray.add("");
		checkerArray.add("1) eat Due: Wednesday, 23/12/2015	[ID:6] ");
		checkerArray.add("");
		checkerArray.add("You have no task today");
		checkerArray.add("");
		checkerArray.add("These are the list of upcoming tasks");
		checkerArray.add("");
		checkerArray.add("1) Dinner with mum Due: Saturday, 12/12/2015	[ID:5] ");
		checkerArray.add("");
		checkerArray.add("These are the tasks you missed");
		checkerArray.add("");
		checkerArray.add("1) Dinner with bf Due: Friday, 06/11/2015	[ID:3] ");
		checkerArray.add("2) Dinner with gf Due: Sunday, 08/11/2015	[ID:4] ");
		checkerArray.add("");

		String checkerString = strArrayToString(checkerArray);

		// compare results
		assertEquals(checkerString, tempRH.processCommand("display all").getCmdPerformed());
		clearFile(tempRH);
	}

	@Test
	public final void testSearchEvents() {
		RequestHandler tempRH = initTempRH();
		clearFile(tempRH);
		tempRH.processCommand("add event Dinner with mum from 21/12/2015 at 19:00 to 23/12/2015 at 19:00");

		// checker for due date
		ArrayList<CalendarObject> checkArray = new ArrayList<CalendarObject>();
		Event event = new Event(0, 0, "Dinner with mum", "21/12/2015/19:00", "23/12/2015/19:00");
		checkArray.add(event);

		String cmdDueDate = String.format(CMD_ADD_EVENT, "Dinner with mum");
		Result tempResult1 = new Result(cmdDueDate, true, putHashMap("events", checkArray));

		// Compare results object
		ArrayList<CalendarObject> expectedArray = getEventArray(tempResult1);
		ArrayList<CalendarObject> actualArray = tempRH.processCommand("search dinner").getResults()
				.get("eventsBestMatches");
		assertEquals(expectedArray.toString(), actualArray.toString());
		clearFile(tempRH);

	}

	@Test
	public final void testAddRecurringEventsDialy() {
		RequestHandler tempRH = initTempRH();
		clearFile(tempRH);

		// checker for due date
		ArrayList<CalendarObject> checkArray = new ArrayList<CalendarObject>();
		Event event = new Event(0, 0, "Dinner with mum", "21/11/2015/19:00", "22/11/2015/19:00");
		Event event1 = new Event(1, 0, "Dinner with mum", "22/11/2015/19:00", "23/11/2015/19:00");
		Event event2 = new Event(2, 0, "Dinner with mum", "23/11/2015/19:00", "24/11/2015/19:00");
		Event event3 = new Event(3, 0, "Dinner with mum", "24/11/2015/19:00", "25/11/2015/19:00");
		checkArray.add(event);
		checkArray.add(event1);
		checkArray.add(event2);
		checkArray.add(event3);

		String cmdDueDate = String.format(CMD_ADD_RECURR_EVENT, "Dinner with mum");
		Result tempResult1 = new Result(cmdDueDate, true, putHashMap(CMD_EVENT, checkArray));

		// Compare results object
		ArrayList<CalendarObject> expectedArray = getEventArray(tempResult1);
		ArrayList<CalendarObject> actualArray = tempRH
				.processCommand(
						"add event Dinner with mum from 21/11/2015 at 19:00 to 22/11/2015 at 19:00 repeat daily till 24/11/2015 ")
				.getResults().get(CMD_EVENT);
		assertEquals(expectedArray.toString(), actualArray.toString());
		clearFile(tempRH);

	}

	@Test
	public final void testAddRecurringEventsWeekly() {
		RequestHandler tempRH = initTempRH();
		clearFile(tempRH);

		// checker for due date
		ArrayList<CalendarObject> checkArray = new ArrayList<CalendarObject>();
		Event event = new Event(0, 0, "Dinner with mum", "21/11/2015/19:00", "22/11/2015/19:00");
		Event event1 = new Event(1, 0, "Dinner with mum", "28/11/2015/19:00", "29/11/2015/19:00");
		Event event2 = new Event(2, 0, "Dinner with mum", "05/12/2015/19:00", "06/12/2015/19:00");
		Event event3 = new Event(3, 0, "Dinner with mum", "12/12/2015/19:00", "13/12/2015/19:00");
		Event event4 = new Event(4, 0, "Dinner with mum", "19/12/2015/19:00", "20/12/2015/19:00");
		Event event5 = new Event(5, 0, "Dinner with mum", "26/12/2015/19:00", "27/12/2015/19:00");
		checkArray.add(event);
		checkArray.add(event1);
		checkArray.add(event2);
		checkArray.add(event3);
		checkArray.add(event4);
		checkArray.add(event5);

		String cmdDueDate = String.format(CMD_ADD_RECURR_EVENT, "Dinner with mum");
		Result tempResult1 = new Result(cmdDueDate, true, putHashMap(CMD_EVENT, checkArray));

		// Compare results object
		ArrayList<CalendarObject> expectedArray = getEventArray(tempResult1);
		ArrayList<CalendarObject> actualArray = tempRH
				.processCommand(
						"add event Dinner with mum from 21/11/2015 at 19:00 to 22/11/2015 at 19:00 repeat weekly till 01/01/2016")
				.getResults().get(CMD_EVENT);
		assertEquals(expectedArray.toString(), actualArray.toString());
		clearFile(tempRH);

	}

	@Test
	public final void testAddRecurringEventsMonthly() {
		RequestHandler tempRH = initTempRH();
		clearFile(tempRH);

		// checker for due date
		ArrayList<CalendarObject> checkArray = new ArrayList<CalendarObject>();
		Event event = new Event(0, 0, "Dinner with mum", "21/11/2015/19:00", "22/11/2015/19:00");
		Event event1 = new Event(1, 0, "Dinner with mum", "21/12/2015/19:00", "22/12/2015/19:00");
		Event event2 = new Event(2, 0, "Dinner with mum", "21/01/2016/19:00", "22/01/2016/19:00");

		checkArray.add(event);
		checkArray.add(event1);
		checkArray.add(event2);

		String cmdDueDate = String.format(CMD_ADD_RECURR_EVENT, "Dinner with mum");
		Result tempResult1 = new Result(cmdDueDate, true, putHashMap(CMD_EVENT, checkArray));

		// Compare results object
		ArrayList<CalendarObject> expectedArray = getEventArray(tempResult1);
		ArrayList<CalendarObject> actualArray = tempRH
				.processCommand(
						"add event Dinner with mum from 21/11/2015 at 19:00 to 22/11/2015 at 19:00 repeat monthly till 01/02/2016")
				.getResults().get(CMD_EVENT);
		assertEquals(expectedArray.toString(), actualArray.toString());
		clearFile(tempRH);

	}

	@Test
	public final void testAddRecurringTasksDaily() {
		RequestHandler tempRH = initTempRH();
		clearFile(tempRH);

		// checker for due date
		ArrayList<CalendarObject> checkArray = new ArrayList<CalendarObject>();
		Task task = new Task(0, 0, "Dinner with mum", "21/11/2015");
		Task task1 = new Task(1, 0, "Dinner with mum", "22/11/2015");
		Task task2 = new Task(2, 0, "Dinner with mum", "23/11/2015");
		Task task3 = new Task(3, 0, "Dinner with mum", "23/11/2015");
		checkArray.add(task);
		checkArray.add(task1);
		checkArray.add(task2);
		checkArray.add(task3);

		String cmdDueDate = String.format(CMD_ADD_RECURR_TASK, "Dinner with mum");
		Result tempResult1 = new Result(cmdDueDate, true, putHashMap(CMD_TASK, checkArray));

		// Compare results object
		ArrayList<CalendarObject> expectedArray = getTaskArray(tempResult1);
		ArrayList<CalendarObject> actualArray = tempRH
				.processCommand("add task Dinner with mum due 21/11/2015 repeat daily till 24/11/2015").getResults()
				.get(CMD_TASK);
		assertEquals(expectedArray.toString().toString(), actualArray.toString());
		clearFile(tempRH);

	}

	@Test
	public final void testAddRecurringTasksWeekly() {
		RequestHandler tempRH = initTempRH();
		clearFile(tempRH);

		// checker for due date
		ArrayList<CalendarObject> checkArray = new ArrayList<CalendarObject>();
		Task task = new Task(0, 0, "Dinner with mum", "21/11/2015");
		Task task1 = new Task(1, 0, "Dinner with mum", "28/11/2015");
		Task task2 = new Task(2, 0, "Dinner with mum", "05/12/2015");

		checkArray.add(task);
		checkArray.add(task1);
		checkArray.add(task2);

		String cmdDueDate = String.format(CMD_ADD_RECURR_TASK, "Dinner with mum");
		Result tempResult1 = new Result(cmdDueDate, true, putHashMap(CMD_TASK, checkArray));

		// Compare results object
		ArrayList<CalendarObject> expectedArray = getTaskArray(tempResult1);
		ArrayList<CalendarObject> actualArray = tempRH
				.processCommand("add task Dinner with mum due 21/11/2015 repeat weekly till 12/12/2015").getResults()
				.get(CMD_TASK);
		assertEquals(actualArray.toString(), expectedArray.toString());
		clearFile(tempRH);

	}

	@Test
	public final void testAddRecurringTasksMonthly() {
		RequestHandler tempRH = initTempRH();
		clearFile(tempRH);

		// checker for due date
		ArrayList<CalendarObject> checkArray = new ArrayList<CalendarObject>();
		Task task = new Task(0, 0, "Dinner with mum", "21/11/2015");
		Task task1 = new Task(1, 0, "Dinner with mum", "21/12/2015");
		Task task2 = new Task(2, 0, "Dinner with mum", "21/01/2016");

		checkArray.add(task);
		checkArray.add(task1);
		checkArray.add(task2);

		String cmdDueDate = String.format(CMD_ADD_RECURR_TASK, "Dinner with mum");
		Result tempResult1 = new Result(cmdDueDate, true, putHashMap(CMD_TASK, checkArray));

		// Compare results object
		ArrayList<CalendarObject> expectedArray = getTaskArray(tempResult1);
		ArrayList<CalendarObject> actualArray = tempRH
				.processCommand("add task Dinner with mum due 21/11/2015 repeat monthly till 01/02/2016").getResults()
				.get(CMD_TASK);
		assertEquals(actualArray.toString(), expectedArray.toString());
		clearFile(tempRH);

	}

	// *****************OTHER METHODS********************//
	private HashMap<String, ArrayList<CalendarObject>> putHashMap(String key, ArrayList<CalendarObject> value) {
		HashMap<String, ArrayList<CalendarObject>> map;
		map = new HashMap<String, ArrayList<CalendarObject>>();
		map.put(key, value);
		return map;
	}

	private RequestHandler initTempRH() {
		String fileName = "testfile.txt";
		RequestHandler tempRH = RequestHandler.getInstance();
		tempRH.initialize(fileName);
		return tempRH;
	}

	private void assertBooleanAndStrCmd(RequestHandler tempRH, Result tempResult, String str) {
		assertEquals(tempResult.getCmdPerformed(), tempRH.processCommand(str).getCmdPerformed());
		assertEquals(tempResult.isSuccess(), tempRH.processCommand(str).isSuccess());
		assertEquals(tempResult.isDisplayResult(), tempRH.processCommand(str).isDisplayResult());
	}

	private void clearFile(RequestHandler tempRH) {
		tempRH.processCommand("clear file");
	}

	private void tryCatchAdd(int pass, RequestHandler tempRH, String str) {
		try {
			tempRH.processCommand(str);
		} catch (NullPointerException ex) {
			pass = 1;
		}
		if (!(pass == 1)) {
			assertTrue(true);
		} else {
			assertTrue(false);
		}
		clearFile(tempRH);
	}

	private ArrayList<CalendarObject> getEventArray(Result tempResult) {
		return tempResult.getResults().get("events");
	}

	private ArrayList<CalendarObject> getTaskArray(Result tempResult) {
		return tempResult.getResults().get("tasks");
	}

	public String strArrayToString(ArrayList<String> in) {
		String s = "";

		for (String str : in) {
			s += str + "\n";
		}

		return s;
	}

}
```
###### Tempo\UnitTesting\TestRequestHandler.java
``` java
public class TestRequestHandler {

	@After
	public void tearDown() throws Exception {
	}

	@Test
	public final void testInit() {
		 String fileName = "testfile.txt";
		 RequestHandler tempRH = RequestHandler.getInstance();
		 assertEquals(fileName+" is ready to use.", tempRH.initialize(fileName));
	}
	
	@Test
	public final void testProcessCalendar() {
		 String fileName = "testfile.txt";
		 RequestHandler tempRH = RequestHandler.getInstance();
		 tempRH.initialize(fileName);
		 Result result = new Result("cmd", false, null);
		 assertEquals(result.getResults(), tempRH.processCommand("cmd").getResults());
		 assertEquals(result.getCmdPerformed(), tempRH.processCommand("cmd").getCmdPerformed());
		 assertEquals(result.isSuccess(), tempRH.processCommand("cmd").isSuccess());
		 
	}
	

}
```
###### Tempo\UnitTesting\TestTasks.java
``` java
public class TestTasks {

	@After
	public void tearDown() throws Exception {
	}
	
	@Test
	public final void testGetName() {
		Task tempTask = new Task(0, 0, "Dinner with mum", "done", "22/12/2015");
		assertEquals("Dinner with mum", tempTask.getName());
	}
	
	@Test
	public final void testGetIndex() {
		Task tempTask = new Task(0, 0, "Dinner with mum", "done", "22/12/2015");
		assertEquals(0, tempTask.getIndex());
	}
	
	@Test
	public final void testGetSeriesIndex() {
		Task tempTask = new Task(0, 0, "Dinner with mum", "done", "22/12/2015");
		assertEquals(0, tempTask.getSeriesIndex());
	}
	
	@Test
	public final void testGetDueDate() {
		Task tempTask = new Task(0, 0, "Dinner with mum", "done", "22/12/2015");
		assertEquals("Tuesday, 22/12/2015", tempTask.getDueDate());
	}
	
	@Test
	public final void testGetDueDateSimplified() {
		Task tempTask = new Task(0, 0, "Dinner with mum", "done", "22/12/2015");
		assertEquals( "22/12/2015", tempTask.getDueDateSimplified());
	}

	@Test
	public final void testUpdateName() {
		Task tempTask = new Task(0, 0, "Dinner with mum", "done", "22/12/2015");
		tempTask.update("name", "changed");
		assertEquals("changed", tempTask.getName());
		
		Task tempTask1 = new Task(0, 0, "Dinner with mum", "22/12/2015");
		tempTask1.update("name", "changed");
		assertEquals("changed", tempTask1.getName());
	}
	
	@Test
	public final void testUpdateDueDate() {
		Task tempTask = new Task(0, 0, "Dinner with mum", "done", "22/12/2015");
		tempTask.update("due", "23/12/2015");
		assertEquals( "23/12/2015", tempTask.getDueDateSimplified());
		
		Task tempTask1 = new Task(0, 0, "Dinner with mum", "22/12/2015");
		tempTask1.update("due", "23/12/2015");
		assertEquals( "23/12/2015", tempTask1.getDueDateSimplified());
	}

	@Test
	public final void testCompareTo() {
		Task tempTask = new Task(0, 0, "Dinner with mum", "done", "22/12/2015");
		Task tempTask1 = new Task(0, 0, "Dinner with mum", "done", "21/12/2015");
		Task tempTask2 = new Task(0, 0, "Dinner with mum", "done", "23/12/2015");
		
		assertEquals(1, tempTask.compareTo(tempTask1));
		assertEquals(0, tempTask.compareTo(tempTask));
		assertEquals(-1, tempTask.compareTo(tempTask2));
		
	}


}
```
